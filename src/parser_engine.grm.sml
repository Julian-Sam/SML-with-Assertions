functor AssertEngineLrValsFun(structure Token : TOKEN)
 : sig structure ParserData : PARSER_DATA
       structure Tokens : AssertEngine_TOKENS
   end
 = 
struct
structure ParserData=
struct
structure Header = 
struct
open String
open Int
exception LabError
exception AssertionError
fun concatWith_(x, lis) = concatWith (x) (lis);
fun spacer(lis) = concatWith_("",lis);
fun spacer'(lis) = concatWith_(" ",lis);

datatype Assert_Type = 
    EMPTY
  | REQ of string
  | ENS of string
  | BOTH of string * string

val final_list_ref: (int list * int list * int list) ref = ref ([], [], []) 
val new_ref: int list ref = ref []
val new_num = ref 1

type stack = Assert_Type list

fun pop (S) = case S of
              []         => ([], EMPTY)
            | elem :: S' => (S', elem)

fun peek (S) = 
  let
    val (_, elem) = pop (S)
  in
    (S, elem)
  end

fun push (S, elem) = elem :: S

val Stack: stack ref = ref []


end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\001\000\107\002\002\000\107\002\003\000\107\002\004\000\107\002\
\\005\000\107\002\006\000\107\002\007\000\107\002\008\000\107\002\
\\009\000\107\002\011\000\107\002\015\000\107\002\016\000\107\002\
\\017\000\107\002\018\000\107\002\020\000\107\002\022\000\106\002\
\\023\000\107\002\024\000\107\002\027\000\107\002\029\000\107\002\
\\030\000\107\002\031\000\107\002\035\000\107\002\036\000\107\002\
\\037\000\107\002\038\000\107\002\039\000\107\002\040\000\107\002\
\\041\000\107\002\044\000\107\002\046\000\107\002\047\000\107\002\
\\048\000\107\002\052\000\107\002\053\000\107\002\054\000\107\002\
\\055\000\107\002\056\000\107\002\058\000\107\002\060\000\107\002\
\\061\000\107\002\067\000\107\002\071\000\107\002\073\000\107\002\000\000\
\\001\000\001\000\051\000\002\000\050\000\003\000\049\000\004\000\048\000\
\\005\000\047\000\006\000\046\000\007\000\045\000\008\000\044\000\
\\009\000\043\000\015\000\059\000\017\000\042\000\018\000\041\000\
\\020\000\040\000\022\000\039\000\024\000\038\000\027\000\037\000\
\\029\000\036\000\032\000\058\000\033\000\057\000\034\000\056\000\
\\035\000\035\000\036\000\034\000\037\000\033\000\039\000\032\000\
\\040\000\031\000\041\000\030\000\044\000\029\000\046\000\028\000\
\\047\000\027\000\048\000\026\000\052\000\025\000\053\000\024\000\
\\054\000\023\000\055\000\022\000\056\000\021\000\058\000\020\000\
\\060\000\019\000\061\000\018\000\067\000\017\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\001\000\051\000\002\000\050\000\003\000\049\000\004\000\048\000\
\\005\000\047\000\006\000\046\000\007\000\045\000\008\000\044\000\
\\009\000\043\000\017\000\042\000\018\000\041\000\020\000\040\000\
\\022\000\039\000\024\000\038\000\027\000\037\000\029\000\036\000\
\\035\000\035\000\036\000\034\000\037\000\033\000\039\000\032\000\
\\040\000\031\000\041\000\030\000\044\000\029\000\046\000\028\000\
\\047\000\027\000\048\000\026\000\052\000\025\000\053\000\024\000\
\\054\000\023\000\055\000\022\000\056\000\021\000\058\000\020\000\
\\060\000\019\000\061\000\018\000\067\000\017\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\002\000\114\002\003\000\114\002\004\000\114\002\005\000\114\002\
\\006\000\114\002\007\000\114\002\008\000\114\002\010\000\114\002\
\\011\000\221\000\013\000\114\002\014\000\114\002\015\000\114\002\
\\017\000\114\002\018\000\114\002\019\000\114\002\020\000\114\002\
\\021\000\114\002\022\000\114\002\023\000\114\002\043\000\114\002\
\\044\000\114\002\051\000\114\002\071\000\114\002\073\000\114\002\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\007\000\045\000\008\000\044\000\017\000\042\000\
\\018\000\041\000\020\000\040\000\021\000\152\000\022\000\039\000\
\\024\000\038\000\027\000\037\000\029\000\036\000\035\000\035\000\
\\039\000\032\000\041\000\030\000\044\000\029\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\007\000\045\000\008\000\044\000\017\000\042\000\
\\018\000\041\000\020\000\040\000\022\000\039\000\023\000\149\000\
\\024\000\038\000\027\000\037\000\029\000\036\000\035\000\035\000\
\\039\000\032\000\041\000\030\000\044\000\029\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\007\000\045\000\008\000\044\000\017\000\042\000\
\\018\000\041\000\020\000\040\000\022\000\039\000\024\000\038\000\
\\027\000\037\000\029\000\036\000\035\000\035\000\039\000\032\000\
\\041\000\030\000\044\000\029\000\071\000\016\000\073\000\015\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\007\000\045\000\008\000\044\000\017\000\042\000\
\\018\000\041\000\020\000\040\000\022\000\039\000\029\000\036\000\
\\044\000\029\000\071\000\016\000\073\000\015\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\021\000\228\000\022\000\125\000\043\000\124\000\
\\044\000\123\000\071\000\122\000\073\000\121\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\021\000\081\001\022\000\125\000\043\000\124\000\
\\044\000\123\000\071\000\122\000\073\000\121\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\022\000\125\000\023\000\225\000\043\000\124\000\
\\044\000\123\000\071\000\122\000\072\000\095\000\073\000\121\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\022\000\125\000\023\000\225\000\043\000\124\000\
\\044\000\123\000\071\000\122\000\073\000\121\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\022\000\125\000\043\000\124\000\044\000\123\000\
\\045\000\133\000\071\000\122\000\073\000\121\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\022\000\125\000\043\000\124\000\044\000\123\000\
\\071\000\122\000\073\000\121\000\000\000\
\\001\000\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\022\000\134\000\043\000\124\000\044\000\123\000\
\\045\000\133\000\071\000\122\000\072\000\095\000\073\000\121\000\000\000\
\\001\000\002\000\080\000\007\000\045\000\008\000\044\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\002\000\082\000\007\000\045\000\008\000\044\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\002\000\160\000\007\000\159\000\008\000\158\000\019\000\157\000\
\\071\000\156\000\073\000\155\000\000\000\
\\001\000\002\000\160\000\007\000\159\000\008\000\158\000\071\000\156\000\
\\073\000\155\000\000\000\
\\001\000\002\000\236\000\008\000\129\000\019\000\235\000\066\000\234\000\
\\071\000\122\000\073\000\233\000\000\000\
\\001\000\002\000\236\000\008\000\129\000\066\000\234\000\071\000\122\000\
\\073\000\233\000\000\000\
\\001\000\002\000\236\000\019\000\013\001\073\000\012\001\000\000\
\\001\000\002\000\236\000\073\000\012\001\000\000\
\\001\000\007\000\224\002\010\000\111\002\015\000\111\002\019\000\111\002\
\\051\000\111\002\000\000\
\\001\000\007\000\045\000\008\000\044\000\022\000\097\000\044\000\111\000\
\\071\000\016\000\072\000\095\000\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\111\000\067\000\017\000\
\\071\000\016\000\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\111\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\138\000\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\050\001\047\000\054\001\
\\071\000\016\000\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\050\001\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\086\001\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\044\000\183\001\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\047\000\009\002\071\000\016\000\
\\073\000\015\000\000\000\
\\001\000\007\000\045\000\008\000\044\000\071\000\016\000\073\000\015\000\000\000\
\\001\000\007\000\098\000\022\000\097\000\071\000\096\000\072\000\095\000\
\\073\000\094\000\000\000\
\\001\000\007\000\098\000\046\000\217\001\071\000\096\000\073\000\094\000\000\000\
\\001\000\007\000\098\000\071\000\096\000\073\000\094\000\000\000\
\\001\000\007\000\185\000\000\000\
\\001\000\007\000\189\000\015\000\188\000\016\000\187\000\000\000\
\\001\000\007\000\202\000\000\000\
\\001\000\007\000\206\000\000\000\
\\001\000\007\000\209\000\000\000\
\\001\000\007\000\238\000\015\000\217\000\051\000\216\000\000\000\
\\001\000\007\000\001\001\000\000\
\\001\000\007\000\046\001\000\000\
\\001\000\007\000\056\001\000\000\
\\001\000\007\000\063\001\015\000\062\001\000\000\
\\001\000\007\000\077\001\000\000\
\\001\000\007\000\140\001\063\000\137\001\000\000\
\\001\000\007\000\141\001\063\000\137\001\000\000\
\\001\000\007\000\169\001\015\000\168\001\000\000\
\\001\000\007\000\197\001\015\000\196\001\016\000\195\001\000\000\
\\001\000\007\000\199\001\000\000\
\\001\000\007\000\209\001\000\000\
\\001\000\007\000\238\001\012\000\006\001\000\000\
\\001\000\007\000\001\002\000\000\
\\001\000\007\000\006\002\000\000\
\\001\000\007\000\014\002\000\000\
\\001\000\007\000\025\002\012\000\006\001\000\000\
\\001\000\007\000\029\002\063\000\137\001\000\000\
\\001\000\007\000\030\002\063\000\137\001\000\000\
\\001\000\007\000\033\002\015\000\032\002\016\000\031\002\000\000\
\\001\000\007\000\037\002\000\000\
\\001\000\007\000\047\002\000\000\
\\001\000\007\000\063\002\000\000\
\\001\000\007\000\066\002\063\000\137\001\000\000\
\\001\000\007\000\067\002\063\000\137\001\000\000\
\\001\000\008\000\129\000\071\000\122\000\073\000\121\000\000\000\
\\001\000\009\000\063\003\023\000\063\003\031\000\063\003\036\000\063\003\
\\037\000\063\003\046\000\063\003\047\000\063\003\058\000\063\003\
\\062\000\063\003\063\000\066\003\064\000\063\003\065\000\063\003\
\\073\000\072\000\000\000\
\\001\000\009\000\252\000\015\000\059\000\031\000\184\001\032\000\058\000\
\\033\000\057\000\034\000\056\000\000\000\
\\001\000\010\000\072\001\014\000\071\001\015\000\217\000\023\000\070\001\
\\051\000\216\000\000\000\
\\001\000\010\000\103\001\012\000\006\001\023\000\102\001\000\000\
\\001\000\013\000\218\000\015\000\217\000\051\000\216\000\000\000\
\\001\000\015\000\059\000\025\000\250\000\032\000\058\000\033\000\057\000\
\\034\000\056\000\000\000\
\\001\000\015\000\059\000\026\000\187\001\032\000\058\000\033\000\057\000\
\\034\000\056\000\000\000\
\\001\000\015\000\059\000\028\000\249\000\032\000\058\000\033\000\057\000\
\\034\000\056\000\000\000\
\\001\000\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\
\\042\000\210\000\000\000\
\\001\000\015\000\181\000\000\000\
\\001\000\015\000\182\000\000\000\
\\001\000\015\000\107\001\000\000\
\\001\000\015\000\111\001\000\000\
\\001\000\015\000\143\001\016\000\142\001\023\000\018\002\000\000\
\\001\000\015\000\143\001\016\000\142\001\031\000\051\002\000\000\
\\001\000\015\000\194\001\000\000\
\\001\000\015\000\206\001\000\000\
\\001\000\015\000\211\001\000\000\
\\001\000\018\000\177\000\022\000\176\000\071\000\175\000\072\000\095\000\
\\073\000\174\000\000\000\
\\001\000\019\000\000\001\000\000\
\\001\000\019\000\075\001\000\000\
\\001\000\019\000\105\001\000\000\
\\001\000\020\000\237\000\000\000\
\\001\000\021\000\255\000\000\000\
\\001\000\021\000\074\001\000\000\
\\001\000\021\000\178\001\000\000\
\\001\000\022\000\184\000\000\000\
\\001\000\022\000\145\001\000\000\
\\001\000\023\000\253\000\000\000\
\\001\000\023\000\254\000\000\000\
\\001\000\023\000\051\001\000\000\
\\001\000\023\000\104\001\000\000\
\\001\000\023\000\109\001\000\000\
\\001\000\023\000\241\001\000\000\
\\001\000\023\000\243\001\000\000\
\\001\000\023\000\254\001\063\000\137\001\000\000\
\\001\000\023\000\017\002\000\000\
\\001\000\029\000\040\001\057\000\039\001\073\000\038\001\000\000\
\\001\000\030\000\194\000\000\000\
\\001\000\030\000\245\000\000\000\
\\001\000\030\000\091\001\000\000\
\\001\000\030\000\232\001\000\000\
\\001\000\030\000\019\002\000\000\
\\001\000\031\000\154\001\000\000\
\\001\000\031\000\156\001\000\000\
\\001\000\031\000\185\001\000\000\
\\001\000\031\000\219\001\000\000\
\\001\000\031\000\226\001\000\000\
\\001\000\031\000\247\001\000\000\
\\001\000\031\000\021\002\000\000\
\\001\000\031\000\065\002\000\000\
\\001\000\040\000\054\000\000\000\
\\001\000\046\000\114\001\073\000\076\000\000\000\
\\001\000\049\000\199\000\050\000\198\000\000\000\
\\001\000\049\000\155\001\000\000\
\\001\000\059\000\031\001\073\000\072\000\000\000\
\\001\000\068\000\180\000\000\000\
\\001\000\069\000\065\000\070\000\064\000\000\000\
\\001\000\071\000\175\000\073\000\174\000\000\000\
\\001\000\072\000\095\000\000\000\
\\001\000\073\000\069\000\000\000\
\\001\000\073\000\072\000\000\000\
\\001\000\073\000\076\000\000\000\
\\074\002\000\000\
\\076\002\000\000\
\\077\002\000\000\
\\078\002\000\000\
\\079\002\000\000\
\\080\002\000\000\
\\081\002\000\000\
\\082\002\000\000\
\\083\002\000\000\
\\084\002\000\000\
\\085\002\000\000\
\\086\002\000\000\
\\087\002\000\000\
\\088\002\000\000\
\\089\002\011\000\062\000\000\000\
\\090\002\000\000\
\\091\002\000\000\
\\092\002\000\000\
\\093\002\000\000\
\\096\002\000\000\
\\097\002\000\000\
\\098\002\000\000\
\\099\002\011\000\237\001\000\000\
\\100\002\000\000\
\\101\002\000\000\
\\102\002\000\000\
\\103\002\000\000\
\\104\002\000\000\
\\105\002\000\000\
\\106\002\000\000\
\\107\002\000\000\
\\108\002\011\000\197\000\000\000\
\\109\002\000\000\
\\110\002\000\000\
\\111\002\000\000\
\\112\002\000\000\
\\113\002\000\000\
\\114\002\011\000\221\000\000\000\
\\115\002\000\000\
\\116\002\009\000\252\000\010\000\251\000\015\000\059\000\032\000\058\000\
\\033\000\057\000\034\000\056\000\000\000\
\\116\002\010\000\251\000\015\000\059\000\032\000\058\000\033\000\057\000\
\\034\000\056\000\000\000\
\\117\002\000\000\
\\118\002\009\000\252\000\015\000\059\000\032\000\058\000\033\000\057\000\
\\034\000\056\000\000\000\
\\119\002\000\000\
\\120\002\000\000\
\\121\002\000\000\
\\122\002\000\000\
\\123\002\000\000\
\\124\002\000\000\
\\125\002\000\000\
\\126\002\000\000\
\\127\002\000\000\
\\128\002\000\000\
\\129\002\000\000\
\\130\002\000\000\
\\131\002\000\000\
\\132\002\000\000\
\\133\002\010\000\188\001\015\000\059\000\032\000\058\000\033\000\057\000\
\\034\000\056\000\000\000\
\\134\002\000\000\
\\135\002\000\000\
\\136\002\000\000\
\\137\002\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\007\000\045\000\008\000\044\000\017\000\042\000\
\\018\000\041\000\020\000\040\000\022\000\039\000\029\000\036\000\
\\044\000\029\000\071\000\016\000\073\000\015\000\000\000\
\\138\002\007\000\045\000\008\000\044\000\071\000\016\000\073\000\015\000\000\000\
\\139\002\007\000\045\000\008\000\044\000\071\000\016\000\073\000\015\000\000\000\
\\140\002\012\000\006\001\000\000\
\\141\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\142\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\143\002\000\000\
\\144\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\145\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\146\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\147\002\000\000\
\\148\002\000\000\
\\149\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\150\002\014\000\220\000\000\000\
\\151\002\000\000\
\\152\002\010\000\052\001\000\000\
\\153\002\000\000\
\\154\002\000\000\
\\155\002\000\000\
\\156\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\
\\070\000\108\001\000\000\
\\157\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\158\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\159\002\000\000\
\\160\002\073\000\076\000\000\000\
\\161\002\000\000\
\\162\002\007\000\045\000\008\000\044\000\071\000\016\000\073\000\015\000\000\000\
\\163\002\000\000\
\\164\002\000\000\
\\165\002\000\000\
\\166\002\000\000\
\\167\002\000\000\
\\168\002\000\000\
\\169\002\000\000\
\\170\002\000\000\
\\171\002\050\000\205\000\000\000\
\\172\002\000\000\
\\173\002\000\000\
\\174\002\000\000\
\\175\002\000\000\
\\176\002\000\000\
\\177\002\000\000\
\\178\002\000\000\
\\179\002\000\000\
\\180\002\000\000\
\\181\002\000\000\
\\182\002\000\000\
\\183\002\009\000\143\000\036\000\034\000\037\000\033\000\040\000\031\000\
\\046\000\028\000\047\000\027\000\048\000\026\000\052\000\025\000\
\\053\000\142\000\054\000\023\000\055\000\022\000\056\000\021\000\
\\067\000\017\000\000\000\
\\184\002\000\000\
\\185\002\000\000\
\\186\002\000\000\
\\187\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\
\\038\000\179\001\000\000\
\\188\002\000\000\
\\189\002\000\000\
\\190\002\002\000\050\000\003\000\049\000\004\000\048\000\005\000\047\000\
\\006\000\046\000\008\000\129\000\017\000\128\000\018\000\127\000\
\\020\000\126\000\022\000\125\000\043\000\124\000\044\000\123\000\
\\071\000\122\000\073\000\121\000\000\000\
\\191\002\000\000\
\\192\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\193\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\194\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\195\002\015\000\059\000\032\000\058\000\033\000\057\000\034\000\056\000\000\000\
\\196\002\014\000\212\000\038\000\211\000\000\000\
\\197\002\000\000\
\\198\002\000\000\
\\199\002\000\000\
\\200\002\012\000\006\001\000\000\
\\201\002\012\000\006\001\000\000\
\\202\002\038\000\207\000\000\000\
\\203\002\000\000\
\\204\002\000\000\
\\205\002\000\000\
\\206\002\038\000\200\000\000\000\
\\207\002\000\000\
\\208\002\042\000\159\001\000\000\
\\209\002\012\000\006\001\000\000\
\\210\002\042\000\236\001\000\000\
\\211\002\012\000\006\001\000\000\
\\212\002\014\000\158\001\000\000\
\\213\002\000\000\
\\214\002\007\000\243\000\042\000\242\000\000\000\
\\215\002\012\000\006\001\000\000\
\\216\002\007\000\088\001\042\000\087\001\000\000\
\\217\002\012\000\006\001\000\000\
\\218\002\000\000\
\\219\002\000\000\
\\220\002\000\000\
\\221\002\000\000\
\\222\002\038\000\241\000\000\000\
\\223\002\000\000\
\\224\002\000\000\
\\225\002\000\000\
\\226\002\008\000\005\001\071\000\175\000\073\000\174\000\000\000\
\\227\002\000\000\
\\228\002\000\000\
\\229\002\011\000\003\001\000\000\
\\230\002\010\000\103\001\012\000\006\001\000\000\
\\231\002\000\000\
\\232\002\012\000\006\001\000\000\
\\233\002\000\000\
\\234\002\010\000\106\001\000\000\
\\235\002\000\000\
\\236\002\000\000\
\\237\002\000\000\
\\238\002\000\000\
\\239\002\000\000\
\\240\002\000\000\
\\241\002\000\000\
\\242\002\000\000\
\\243\002\012\000\006\001\000\000\
\\244\002\008\000\005\001\071\000\175\000\073\000\174\000\000\000\
\\245\002\010\000\073\001\015\000\217\000\051\000\216\000\000\000\
\\246\002\000\000\
\\247\002\014\000\242\001\015\000\217\000\051\000\216\000\000\000\
\\248\002\000\000\
\\251\002\015\000\217\000\051\000\216\000\000\000\
\\252\002\012\000\006\001\000\000\
\\253\002\000\000\
\\254\002\000\000\
\\255\002\000\000\
\\001\003\000\000\
\\002\003\000\000\
\\003\003\000\000\
\\004\003\000\000\
\\005\003\000\000\
\\006\003\000\000\
\\007\003\000\000\
\\008\003\000\000\
\\009\003\000\000\
\\010\003\000\000\
\\011\003\000\000\
\\012\003\000\000\
\\013\003\000\000\
\\014\003\015\000\217\000\051\000\216\000\000\000\
\\015\003\015\000\079\001\051\000\078\001\000\000\
\\016\003\015\000\217\000\051\000\216\000\000\000\
\\017\003\012\000\006\001\051\000\244\001\000\000\
\\018\003\015\000\217\000\051\000\216\000\000\000\
\\019\003\010\000\076\001\000\000\
\\020\003\000\000\
\\021\003\000\000\
\\022\003\000\000\
\\023\003\000\000\
\\024\003\000\000\
\\025\003\063\000\137\001\000\000\
\\026\003\063\000\137\001\000\000\
\\027\003\000\000\
\\028\003\022\000\145\001\000\000\
\\029\003\022\000\145\001\000\000\
\\030\003\000\000\
\\031\003\000\000\
\\032\003\000\000\
\\033\003\000\000\
\\034\003\000\000\
\\035\003\000\000\
\\036\003\000\000\
\\037\003\000\000\
\\038\003\009\000\152\001\029\000\040\001\036\000\034\000\037\000\033\000\
\\040\000\031\000\046\000\028\000\047\000\027\000\048\000\026\000\
\\052\000\025\000\053\000\151\001\054\000\023\000\055\000\022\000\
\\056\000\021\000\057\000\039\001\058\000\150\001\061\000\149\001\
\\067\000\017\000\073\000\038\001\000\000\
\\038\003\009\000\152\001\036\000\034\000\037\000\033\000\040\000\031\000\
\\046\000\028\000\047\000\027\000\048\000\026\000\052\000\025\000\
\\053\000\151\001\054\000\023\000\055\000\022\000\056\000\021\000\
\\058\000\150\001\061\000\149\001\067\000\017\000\000\000\
\\039\003\000\000\
\\040\003\000\000\
\\041\003\009\000\085\000\036\000\034\000\037\000\033\000\040\000\031\000\
\\046\000\028\000\047\000\027\000\048\000\026\000\052\000\025\000\
\\053\000\024\000\054\000\023\000\055\000\022\000\056\000\021\000\
\\058\000\020\000\060\000\019\000\061\000\018\000\067\000\017\000\000\000\
\\042\003\000\000\
\\043\003\000\000\
\\044\003\000\000\
\\045\003\000\000\
\\046\003\000\000\
\\047\003\036\000\034\000\037\000\033\000\040\000\031\000\046\000\028\000\
\\047\000\027\000\048\000\026\000\052\000\025\000\053\000\024\000\
\\054\000\023\000\055\000\022\000\056\000\021\000\058\000\020\000\
\\060\000\019\000\061\000\018\000\067\000\017\000\000\000\
\\048\003\000\000\
\\049\003\015\000\143\001\016\000\142\001\000\000\
\\050\003\015\000\143\001\016\000\142\001\000\000\
\\051\003\015\000\143\001\016\000\142\001\000\000\
\\052\003\038\000\186\000\000\000\
\\053\003\000\000\
\\054\003\012\000\006\001\000\000\
\\055\003\012\000\006\001\000\000\
\\056\003\000\000\
\\057\003\038\000\013\002\000\000\
\\058\003\000\000\
\\059\003\007\000\001\002\000\000\
\\060\003\000\000\
\\061\003\007\000\199\001\000\000\
\\062\003\000\000\
\\063\003\073\000\072\000\000\000\
\\064\003\000\000\
\\065\003\000\000\
\\066\003\000\000\
\\067\003\000\000\
\\069\003\038\000\138\001\063\000\137\001\000\000\
\\070\003\000\000\
\\071\003\000\000\
\\072\003\000\000\
\\073\003\000\000\
\\074\003\000\000\
\\075\003\000\000\
\\076\003\000\000\
\\077\003\000\000\
\\078\003\063\000\137\001\000\000\
\\079\003\000\000\
\\080\003\000\000\
\\081\003\000\000\
\\082\003\000\000\
\\083\003\009\000\028\001\036\000\027\001\037\000\026\001\046\000\025\001\
\\047\000\024\001\058\000\023\001\062\000\022\001\064\000\021\001\
\\065\000\020\001\000\000\
\\083\003\009\000\028\001\036\000\027\001\037\000\026\001\046\000\025\001\
\\047\000\024\001\058\000\023\001\062\000\022\001\064\000\021\001\
\\065\000\020\001\073\000\076\000\000\000\
\\084\003\000\000\
\\085\003\000\000\
\\086\003\012\000\006\001\038\000\042\002\000\000\
\\087\003\000\000\
\\088\003\000\000\
\\088\003\007\000\209\000\000\000\
\\089\003\000\000\
\\089\003\007\000\056\001\000\000\
\\090\003\038\000\202\001\000\000\
\\091\003\000\000\
\\092\003\000\000\
\\093\003\000\000\
\\094\003\038\000\207\001\000\000\
\\095\003\000\000\
\\096\003\014\000\040\002\042\000\039\002\000\000\
\\097\003\012\000\006\001\014\000\068\002\000\000\
\\098\003\000\000\
\\099\003\000\000\
\\100\003\038\000\213\001\042\000\212\001\000\000\
\\101\003\012\000\006\001\038\000\043\002\000\000\
\\102\003\000\000\
\\103\003\000\000\
\\104\003\038\000\036\002\063\000\137\001\000\000\
\\105\003\000\000\
\\106\003\015\000\143\001\016\000\142\001\000\000\
\\107\003\015\000\143\001\016\000\142\001\000\000\
\\108\003\015\000\143\001\016\000\142\001\000\000\
\\109\003\015\000\143\001\016\000\142\001\000\000\
\\110\003\015\000\143\001\016\000\142\001\000\000\
\\111\003\015\000\143\001\016\000\142\001\000\000\
\\112\003\038\000\183\000\000\000\
\\113\003\000\000\
\"
val actionRowNumbers =
"\003\000\132\000\101\001\003\000\
\\100\001\120\000\002\000\195\000\
\\193\000\191\000\177\000\146\000\
\\176\000\142\000\143\000\126\000\
\\129\000\130\000\131\000\034\000\
\\016\000\017\000\095\001\131\000\
\\035\000\035\000\035\000\034\000\
\\007\000\025\000\014\000\015\000\
\\028\000\007\000\239\000\007\000\
\\007\000\006\000\005\000\018\000\
\\019\000\003\000\145\000\144\000\
\\141\000\140\000\138\000\139\000\
\\137\000\133\000\102\001\136\000\
\\025\000\135\000\014\000\007\000\
\\007\000\087\000\008\000\192\000\
\\034\000\125\000\078\000\079\000\
\\098\001\168\001\095\000\161\000\
\\097\001\038\000\165\000\096\001\
\\106\001\039\000\162\000\238\000\
\\218\000\235\000\034\000\234\000\
\\034\000\095\001\107\000\095\001\
\\233\000\216\000\163\000\122\000\
\\006\001\037\000\040\000\210\000\
\\151\000\148\000\152\000\128\000\
\\153\000\227\000\041\000\226\000\
\\002\001\037\000\042\000\178\000\
\\077\000\224\000\252\000\027\000\
\\014\000\034\000\052\001\073\000\
\\246\000\051\001\204\000\206\000\
\\058\001\004\000\059\001\166\000\
\\167\000\068\000\060\001\012\000\
\\009\000\020\000\091\000\168\000\
\\043\000\220\000\013\000\013\000\
\\011\000\232\000\022\001\014\001\
\\034\000\200\000\108\000\239\000\
\\239\000\239\000\076\000\074\000\
\\171\000\097\000\098\000\182\000\
\\172\000\092\000\184\000\088\000\
\\044\000\156\000\157\000\179\000\
\\159\000\158\000\160\000\181\000\
\\134\000\222\000\027\000\199\000\
\\197\000\198\000\041\001\029\001\
\\044\001\196\000\042\001\035\001\
\\149\000\150\000\087\000\022\000\
\\194\000\147\000\215\000\007\000\
\\007\000\129\000\137\001\124\000\
\\131\000\124\000\124\000\106\000\
\\219\000\237\000\236\000\093\001\
\\095\001\094\001\217\000\131\000\
\\035\000\239\000\035\000\045\000\
\\030\000\099\000\208\000\035\000\
\\029\000\035\000\046\000\087\000\
\\014\000\026\000\027\000\225\000\
\\047\000\014\000\014\000\087\000\
\\007\000\247\000\014\000\068\000\
\\057\001\169\000\071\000\054\001\
\\045\001\093\000\061\001\089\000\
\\072\001\048\000\068\001\024\000\
\\074\001\065\001\025\001\010\000\
\\007\000\221\000\245\000\028\000\
\\087\000\031\000\016\001\007\000\
\\240\000\109\000\241\000\007\000\
\\007\000\007\000\007\000\186\000\
\\183\000\185\000\180\000\007\000\
\\223\000\127\000\040\001\087\000\
\\087\000\072\000\100\000\090\000\
\\034\001\080\000\024\001\037\001\
\\213\000\212\000\169\001\101\000\
\\136\001\081\000\121\000\035\000\
\\124\000\034\000\035\000\035\000\
\\034\000\034\000\136\001\122\001\
\\120\001\136\001\107\001\049\000\
\\050\000\103\001\096\000\076\001\
\\001\000\092\001\092\001\112\000\
\\164\000\123\000\113\000\007\001\
\\030\000\004\001\012\001\008\001\
\\034\000\211\000\128\000\228\000\
\\037\000\003\001\087\000\000\001\
\\203\000\254\000\027\000\253\000\
\\087\000\007\000\051\000\049\001\
\\050\001\205\000\207\000\170\000\
\\053\001\014\000\014\000\014\000\
\\062\001\066\001\021\000\014\000\
\\014\000\087\000\094\000\063\001\
\\243\000\023\001\015\001\018\001\
\\034\000\087\000\032\000\070\000\
\\114\000\239\000\202\000\075\000\
\\173\000\174\000\175\000\189\000\
\\028\001\026\001\027\001\043\001\
\\039\001\087\000\037\000\036\001\
\\023\000\087\000\084\000\052\000\
\\138\001\124\000\135\001\053\000\
\\037\000\126\001\146\001\037\000\
\\142\001\131\001\133\001\069\000\
\\130\001\085\000\127\001\150\001\
\\037\000\054\000\125\001\132\001\
\\037\000\143\001\124\001\086\000\
\\129\001\156\001\139\001\036\000\
\\130\000\115\000\106\000\106\000\
\\124\000\124\000\077\001\091\001\
\\116\000\092\001\085\001\129\000\
\\131\000\092\001\092\001\110\000\
\\099\001\239\000\230\000\005\001\
\\030\000\087\000\010\001\209\000\
\\229\000\154\000\001\001\255\000\
\\055\000\248\000\087\000\007\000\
\\102\000\047\001\103\000\046\001\
\\073\001\067\001\069\001\070\001\
\\064\001\013\000\019\001\017\001\
\\020\001\034\000\187\000\188\000\
\\117\000\007\000\019\000\030\001\
\\031\001\038\001\033\001\032\001\
\\007\000\124\000\124\000\106\000\
\\104\000\131\000\134\001\056\000\
\\035\000\144\001\118\001\117\001\
\\124\000\035\000\057\000\033\000\
\\145\001\087\000\087\000\034\000\
\\121\001\111\001\058\000\035\000\
\\123\001\119\001\105\001\104\001\
\\079\001\078\001\105\000\082\000\
\\075\001\089\001\087\001\086\001\
\\111\000\090\001\106\000\118\000\
\\013\001\009\001\087\000\037\000\
\\007\000\059\000\250\000\056\001\
\\014\000\055\001\014\000\244\000\
\\021\001\239\000\201\000\190\000\
\\214\000\060\000\061\000\165\001\
\\062\000\116\001\115\001\037\000\
\\147\001\160\001\151\001\063\000\
\\034\000\148\001\152\001\037\000\
\\140\001\157\001\158\001\036\000\
\\037\000\037\000\064\000\081\001\
\\082\001\092\001\083\000\231\000\
\\011\001\155\000\249\000\007\000\
\\048\001\071\001\242\000\106\000\
\\106\000\124\000\124\000\106\000\
\\114\001\113\001\034\000\034\000\
\\149\001\087\000\034\000\128\001\
\\034\000\034\000\112\001\110\001\
\\065\000\087\000\083\001\084\001\
\\119\000\080\001\251\000\167\001\
\\166\001\066\000\067\000\162\001\
\\161\001\153\001\154\001\141\001\
\\159\001\087\000\108\001\088\001\
\\106\000\106\000\034\000\109\001\
\\164\001\163\001\155\001\000\000"
val gotoT =
"\
\\001\000\071\002\002\000\012\000\003\000\011\000\004\000\010\000\
\\017\000\009\000\019\000\008\000\020\000\007\000\021\000\006\000\
\\027\000\005\000\030\000\004\000\058\000\003\000\059\000\002\000\
\\085\000\001\000\000\000\
\\000\000\
\\027\000\005\000\030\000\004\000\058\000\050\000\059\000\002\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\006\000\027\000\005\000\
\\030\000\004\000\058\000\003\000\059\000\002\000\085\000\051\000\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\006\000\027\000\005\000\
\\030\000\004\000\058\000\003\000\059\000\002\000\085\000\053\000\000\000\
\\003\000\058\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\059\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\026\000\061\000\000\000\
\\012\000\066\000\080\000\065\000\081\000\064\000\000\000\
\\011\000\069\000\069\000\068\000\000\000\
\\009\000\073\000\060\000\072\000\061\000\071\000\000\000\
\\003\000\076\000\029\000\075\000\000\000\
\\003\000\076\000\029\000\077\000\000\000\
\\003\000\076\000\029\000\079\000\000\000\
\\027\000\005\000\030\000\004\000\057\000\082\000\059\000\081\000\000\000\
\\009\000\086\000\010\000\085\000\028\000\084\000\000\000\
\\005\000\091\000\006\000\090\000\025\000\089\000\038\000\088\000\
\\039\000\087\000\000\000\
\\005\000\091\000\006\000\098\000\025\000\089\000\038\000\088\000\
\\039\000\097\000\000\000\
\\005\000\091\000\006\000\102\000\025\000\101\000\036\000\100\000\
\\037\000\099\000\000\000\
\\003\000\011\000\004\000\103\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\104\000\000\000\
\\003\000\108\000\005\000\091\000\025\000\107\000\034\000\106\000\
\\035\000\105\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\022\000\115\000\
\\023\000\114\000\033\000\113\000\050\000\112\000\052\000\111\000\
\\093\000\110\000\000\000\
\\002\000\118\000\005\000\091\000\013\000\117\000\014\000\116\000\
\\025\000\130\000\032\000\129\000\033\000\113\000\050\000\112\000\
\\052\000\128\000\093\000\110\000\000\000\
\\003\000\135\000\042\000\134\000\043\000\133\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\137\000\000\000\
\\027\000\005\000\030\000\139\000\031\000\138\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\142\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\143\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\015\000\146\000\
\\016\000\145\000\017\000\009\000\019\000\008\000\020\000\007\000\
\\021\000\144\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\015\000\149\000\
\\017\000\009\000\019\000\008\000\020\000\007\000\021\000\148\000\000\000\
\\008\000\152\000\018\000\151\000\000\000\
\\008\000\159\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\006\000\027\000\005\000\
\\030\000\004\000\058\000\003\000\059\000\002\000\085\000\160\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\108\000\005\000\091\000\025\000\162\000\034\000\106\000\
\\035\000\161\000\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\022\000\115\000\
\\023\000\163\000\033\000\113\000\050\000\112\000\052\000\111\000\
\\093\000\110\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\164\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\165\000\000\000\
\\005\000\171\000\044\000\170\000\046\000\169\000\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\176\000\000\000\
\\000\000\
\\003\000\011\000\004\000\177\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\076\000\029\000\188\000\000\000\
\\000\000\
\\003\000\076\000\029\000\189\000\000\000\
\\000\000\
\\003\000\076\000\029\000\190\000\000\000\
\\027\000\005\000\030\000\004\000\057\000\191\000\059\000\081\000\000\000\
\\000\000\
\\027\000\005\000\030\000\004\000\057\000\193\000\059\000\081\000\000\000\
\\000\000\
\\009\000\086\000\010\000\085\000\028\000\194\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\199\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\202\000\024\000\201\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\206\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\108\000\034\000\106\000\035\000\211\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\212\000\
\\050\000\112\000\093\000\110\000\000\000\
\\003\000\213\000\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\217\000\
\\050\000\112\000\093\000\110\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\013\000\221\000\014\000\220\000\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\222\000\093\000\110\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\048\000\225\000\050\000\112\000\052\000\224\000\093\000\110\000\000\000\
\\013\000\230\000\086\000\229\000\091\000\228\000\092\000\227\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\032\000\237\000\
\\033\000\113\000\050\000\112\000\052\000\128\000\093\000\110\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\032\000\238\000\
\\033\000\113\000\050\000\112\000\052\000\128\000\093\000\110\000\000\000\
\\002\000\118\000\005\000\202\000\013\000\117\000\014\000\116\000\
\\024\000\201\000\033\000\113\000\050\000\112\000\052\000\222\000\
\\093\000\110\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\242\000\000\000\
\\000\000\
\\000\000\
\\027\000\005\000\030\000\139\000\031\000\244\000\000\000\
\\027\000\005\000\030\000\139\000\031\000\245\000\000\000\
\\027\000\005\000\030\000\139\000\031\000\246\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\108\000\034\000\106\000\035\000\000\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\095\000\167\000\096\000\002\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\045\000\006\001\046\000\005\001\
\\089\000\168\000\095\000\167\000\096\000\166\000\000\000\
\\086\000\009\001\087\000\008\001\088\000\007\001\000\000\
\\003\000\058\000\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\012\001\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\013\001\000\000\
\\012\000\066\000\080\000\065\000\081\000\014\001\000\000\
\\009\000\017\001\070\000\016\001\071\000\015\001\000\000\
\\011\000\028\001\067\000\027\001\000\000\
\\009\000\073\000\060\000\072\000\061\000\030\001\000\000\
\\011\000\028\001\067\000\031\001\000\000\
\\011\000\028\001\067\000\032\001\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\033\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\027\000\005\000\030\000\004\000\057\000\039\001\059\000\081\000\000\000\
\\000\000\
\\000\000\
\\009\000\086\000\010\000\040\001\000\000\
\\005\000\091\000\006\000\102\000\025\000\101\000\036\000\100\000\
\\037\000\041\001\000\000\
\\027\000\005\000\030\000\139\000\031\000\042\001\000\000\
\\005\000\091\000\006\000\090\000\025\000\089\000\038\000\088\000\
\\039\000\043\001\000\000\
\\000\000\
\\003\000\047\001\040\000\046\001\041\000\045\001\000\000\
\\000\000\
\\000\000\
\\005\000\091\000\006\000\102\000\025\000\101\000\036\000\100\000\
\\037\000\051\001\000\000\
\\003\000\047\001\040\000\046\001\041\000\045\001\000\000\
\\005\000\091\000\006\000\102\000\025\000\101\000\036\000\100\000\
\\037\000\053\001\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\055\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\022\000\115\000\
\\023\000\056\001\033\000\113\000\050\000\112\000\052\000\111\000\
\\093\000\110\000\000\000\
\\003\000\108\000\027\000\058\001\034\000\106\000\035\000\057\001\000\000\
\\003\000\108\000\034\000\106\000\035\000\059\001\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\062\001\
\\050\000\112\000\093\000\110\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\063\001\093\000\110\000\000\000\
\\005\000\171\000\044\000\170\000\046\000\064\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\065\001\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\022\000\115\000\
\\023\000\066\001\033\000\113\000\050\000\112\000\052\000\111\000\
\\093\000\110\000\000\000\
\\013\000\221\000\014\000\067\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\048\000\078\001\050\000\112\000\052\000\224\000\093\000\110\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\080\001\000\000\
\\000\000\
\\000\000\
\\003\000\135\000\042\000\134\000\043\000\081\001\000\000\
\\005\000\171\000\044\000\170\000\046\000\082\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\003\000\011\000\004\000\083\001\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\016\000\088\001\
\\017\000\009\000\019\000\008\000\020\000\007\000\021\000\087\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\090\001\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\091\001\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\015\000\092\001\
\\017\000\009\000\019\000\008\000\020\000\007\000\021\000\148\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\016\000\094\001\
\\017\000\009\000\019\000\008\000\020\000\007\000\021\000\093\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\095\001\000\000\
\\000\000\
\\095\000\167\000\096\000\096\001\000\000\
\\000\000\
\\005\000\171\000\044\000\098\001\089\000\097\001\095\000\167\000\
\\096\000\166\000\000\000\
\\005\000\171\000\044\000\170\000\046\000\099\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\070\000\016\001\071\000\108\001\000\000\
\\000\000\
\\009\000\086\000\010\000\111\001\065\000\110\001\000\000\
\\005\000\091\000\006\000\116\001\025\000\115\001\073\000\114\001\
\\074\000\113\001\000\000\
\\011\000\119\001\066\000\118\001\067\000\117\001\000\000\
\\003\000\121\001\079\000\120\001\000\000\
\\005\000\091\000\006\000\125\001\025\000\124\001\075\000\123\001\
\\076\000\122\001\000\000\
\\005\000\091\000\006\000\129\001\025\000\128\001\036\000\100\000\
\\037\000\127\001\073\000\114\001\074\000\126\001\000\000\
\\003\000\131\001\072\000\130\001\000\000\
\\003\000\133\001\078\000\132\001\000\000\
\\070\000\016\001\071\000\134\001\000\000\
\\000\000\
\\000\000\
\\070\000\016\001\071\000\137\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\054\000\142\001\000\000\
\\000\000\
\\000\000\
\\027\000\005\000\030\000\146\001\055\000\145\001\056\000\144\001\000\000\
\\027\000\005\000\030\000\146\001\055\000\145\001\056\000\151\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\047\001\040\000\046\001\041\000\155\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\158\001\000\000\
\\000\000\
\\005\000\202\000\024\000\159\001\000\000\
\\000\000\
\\006\000\161\001\007\000\160\001\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\162\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\108\000\034\000\106\000\035\000\163\001\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\164\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\165\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\169\001\093\000\110\000\094\000\168\001\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\048\000\170\001\050\000\112\000\052\000\224\000\093\000\110\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\048\000\171\001\050\000\112\000\052\000\224\000\093\000\110\000\000\000\
\\000\000\
\\000\000\
\\013\000\230\000\086\000\229\000\091\000\228\000\092\000\172\001\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\173\001\093\000\110\000\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\174\001\093\000\110\000\000\000\
\\005\000\171\000\044\000\170\000\046\000\175\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\011\000\004\000\178\001\000\000\
\\005\000\171\000\044\000\170\000\046\000\179\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\003\000\011\000\004\000\180\001\000\000\
\\000\000\
\\000\000\
\\027\000\005\000\030\000\139\000\031\000\184\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\095\000\167\000\096\000\002\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\045\000\188\001\046\000\187\001\
\\089\000\168\000\095\000\167\000\096\000\166\000\000\000\
\\006\000\161\001\007\000\189\001\000\000\
\\000\000\
\\086\000\009\001\087\000\008\001\088\000\190\001\000\000\
\\005\000\171\000\044\000\170\000\046\000\191\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\028\001\067\000\196\001\000\000\
\\000\000\
\\000\000\
\\006\000\161\001\007\000\199\001\064\000\198\001\000\000\
\\000\000\
\\000\000\
\\006\000\201\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\203\001\066\000\202\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\206\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\208\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\161\001\007\000\214\001\062\000\213\001\063\000\212\001\000\000\
\\011\000\069\000\069\000\216\001\000\000\
\\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\218\001\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\219\001\000\000\
\\011\000\028\001\067\000\220\001\000\000\
\\011\000\028\001\067\000\221\001\000\000\
\\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\027\000\005\000\
\\030\000\146\001\053\000\223\001\055\000\145\001\056\000\222\001\000\000\
\\000\000\
\\027\000\005\000\030\000\146\001\055\000\145\001\056\000\225\001\000\000\
\\000\000\
\\012\000\066\000\080\000\065\000\081\000\226\001\000\000\
\\009\000\073\000\060\000\072\000\061\000\227\001\000\000\
\\027\000\005\000\030\000\146\001\055\000\145\001\056\000\228\001\000\000\
\\027\000\005\000\030\000\146\001\055\000\145\001\056\000\229\001\000\000\
\\000\000\
\\000\000\
\\027\000\005\000\030\000\139\000\031\000\231\001\000\000\
\\000\000\
\\000\000\
\\003\000\047\001\040\000\046\001\041\000\232\001\000\000\
\\005\000\171\000\044\000\170\000\046\000\233\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\237\001\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\238\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\032\000\243\001\
\\033\000\113\000\050\000\112\000\052\000\128\000\093\000\110\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\011\000\004\000\244\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\246\001\000\000\
\\008\000\152\000\018\000\247\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\248\001\000\000\
\\011\000\028\001\067\000\249\001\000\000\
\\011\000\028\001\067\000\250\001\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\251\001\000\000\
\\000\000\
\\009\000\086\000\010\000\254\001\065\000\253\001\000\000\
\\000\000\
\\000\000\
\\005\000\091\000\006\000\116\001\025\000\115\001\073\000\114\001\
\\074\000\000\002\000\000\
\\000\000\
\\000\000\
\\011\000\203\001\066\000\202\001\000\000\
\\011\000\028\001\067\000\001\002\000\000\
\\005\000\091\000\006\000\003\002\025\000\124\001\075\000\123\001\
\\076\000\002\002\000\000\
\\000\000\
\\003\000\006\002\077\000\005\002\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\008\002\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\005\000\171\000\044\000\170\000\046\000\009\002\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\003\000\133\001\078\000\010\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\091\000\006\000\161\001\007\000\014\002\025\000\013\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\018\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\020\002\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\006\000\161\001\007\000\021\002\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\022\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\169\001\093\000\110\000\094\000\024\002\000\000\
\\000\000\
\\002\000\118\000\013\000\117\000\014\000\116\000\033\000\113\000\
\\050\000\112\000\052\000\025\002\093\000\110\000\000\000\
\\000\000\
\\000\000\
\\027\000\005\000\030\000\139\000\031\000\026\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\161\001\007\000\033\002\064\000\032\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\003\000\006\002\077\000\036\002\000\000\
\\000\000\
\\000\000\
\\006\000\161\001\007\000\039\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\161\001\007\000\214\001\062\000\213\001\063\000\042\002\000\000\
\\006\000\161\001\007\000\043\002\000\000\
\\006\000\161\001\007\000\044\002\000\000\
\\000\000\
\\054\000\046\002\000\000\
\\054\000\047\002\000\000\
\\027\000\005\000\030\000\146\001\055\000\145\001\056\000\048\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\012\000\003\000\011\000\004\000\010\000\017\000\009\000\
\\019\000\008\000\020\000\007\000\021\000\050\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\051\002\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\052\002\000\000\
\\011\000\028\001\067\000\053\002\000\000\
\\011\000\028\001\067\000\054\002\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\055\002\000\000\
\\000\000\
\\000\000\
\\003\000\121\001\079\000\056\002\000\000\
\\003\000\006\002\077\000\005\002\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\057\002\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\003\000\006\002\077\000\058\002\000\000\
\\000\000\
\\003\000\131\001\072\000\059\002\000\000\
\\003\000\133\001\078\000\060\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\062\002\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\005\000\171\000\044\000\170\000\046\000\067\002\089\000\168\000\
\\095\000\167\000\096\000\166\000\000\000\
\\000\000\
\\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\068\002\000\000\
\\009\000\086\000\010\000\035\001\012\000\034\001\053\000\069\002\000\000\
\\003\000\006\002\077\000\070\002\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 584
val numrules = 296
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle General.Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(List.map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = int
type arg = unit
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | ID of unit ->  (string) | QUOTE_ID of unit ->  (string)
 | SYMBOLS of unit ->  (string) | ENSURES of unit ->  (string)
 | REQUIRES of unit ->  (string) | RASSERT of unit ->  (string)
 | LASSERT of unit ->  (string) | DOTTED_WILDCARD of unit ->  (string)
 | SHARING of unit ->  (string) | EQTYPE of unit ->  (string)
 | WHERE of unit ->  (string) | INCLUDE of unit ->  (string)
 | FUNCTOR of unit ->  (string) | SIGNATURE of unit ->  (string)
 | SIG of unit ->  (string) | STRUCTURE of unit ->  (string)
 | STRUCT of unit ->  (string) | NONFIX of unit ->  (string)
 | INFIXR of unit ->  (string) | INFIX of unit ->  (string)
 | LOCAL of unit ->  (string) | OPEN of unit ->  (string)
 | AS of unit ->  (string) | WITHTYPE of unit ->  (string)
 | WITH of unit ->  (string) | ABSTYPE of unit ->  (string)
 | DATATYPE of unit ->  (string) | TYPE of unit ->  (string)
 | REC of unit ->  (string) | OP of unit ->  (string)
 | WILD of unit ->  (string) | OF of unit ->  (string)
 | CASE of unit ->  (string) | FUN of unit ->  (string)
 | FN of unit ->  (string) | AND of unit ->  (string)
 | VAL of unit ->  (string) | EXCEPTION of unit ->  (string)
 | RAISE of unit ->  (string) | HANDLE of unit ->  (string)
 | ANDALSO of unit ->  (string) | ORELSE of unit ->  (string)
 | END of unit ->  (string) | IN of unit ->  (string)
 | LET of unit ->  (string) | DO of unit ->  (string)
 | WHILE of unit ->  (string) | ELSE of unit ->  (string)
 | THEN of unit ->  (string) | IF of unit ->  (string)
 | RPAREN of unit ->  (string) | LPAREN of unit ->  (string)
 | RBRACK of unit ->  (string) | LBRACK of unit ->  (string)
 | RCURLY of unit ->  (string) | LCURLY of unit ->  (string)
 | HASH of unit ->  (string) | COLONGT of unit ->  (string)
 | COLON of unit ->  (string) | BAR of unit ->  (string)
 | DARROW of unit ->  (string) | ARROW of unit ->  (string)
 | DOT of unit ->  (string) | COMMA of unit ->  (string)
 | SEMICOLON of unit ->  (string) | TIMES of unit ->  (string)
 | EQUALOP of unit ->  (string) | STRING of unit ->  (string)
 | CHAR of unit ->  (string) | WORD of unit ->  (string)
 | REAL of unit ->  (string) | INT of unit ->  (string)
 | EOF of unit ->  ( ( int list * int list * int list )  ref)
 | EXP_A of unit ->  (string) | INF_EXP_A of unit ->  (string)
 | APP_EXP_A of unit ->  (string) | EXP_A_ROW of unit ->  (string)
 | AT_EXP_A of unit ->  (string) | EXP_A_SEQ of unit ->  (string)
 | EXP_A_LIST of unit ->  (string) | TY_CON of unit ->  (string)
 | ALL_IDs of unit ->  (string) | OR_PAT_LIST of unit ->  (string)
 | AT_PAT' of unit ->  (string) | PLABELS of unit ->  (string)
 | PLABEL of unit ->  (string) | QID of unit ->  (string)
 | TYP' of unit ->  (string) | TLABELS of unit ->  (string)
 | TLABEL of unit ->  (string) | SELECTOR of unit ->  (string)
 | PROGRAM of unit ->  (string) | PROGRAM' of unit ->  (string)
 | TOP_DEC of unit ->  (string) | TOP_DEC' of unit ->  (string)
 | FUN_BIND of unit ->  (string) | FUN_BIND' of unit ->  (string)
 | STR_DESC of unit ->  (string) | EX_DESC of unit ->  (string)
 | CON_DESC of unit ->  (string) | DAT_DESC of unit ->  (string)
 | DAT_DESC' of unit ->  (string) | TYP_DESC of unit ->  (string)
 | TYP_DESC' of unit ->  (string) | VAL_DESC of unit ->  (string)
 | SPEC of unit ->  (string) | SPEC' of unit ->  (string)
 | SIG_BIND of unit ->  (string) | SIG_DEC of unit ->  (string)
 | SIG_EXP of unit ->  (string) | SIG_ID_SPCE_SEQ of unit ->  (string)
 | LONG_STR_ID_EQ_SEQ of unit ->  (string)
 | LONG_TY_CON_EQ_SEQ of unit ->  (string)
 | TYP_REFINE of unit ->  (string) | TYP_REFINE' of unit ->  (string)
 | STR_BIND of unit ->  (string) | STR_BIND' of unit ->  (string)
 | S_DEC' of unit ->  (string) | S_DEC of unit ->  (string)
 | S_DECS of unit ->  (string) | STR_DEC of unit ->  (string)
 | STR_DEC' of unit ->  (string) | ARG_FCT of unit ->  (string)
 | STR_EXP of unit ->  (string) | PAT of unit ->  (string)
 | PAT_ROW of unit ->  (string) | AT_PAT of unit ->  (string)
 | PAT_TUPLE of unit ->  (string) | PAT_LIST of unit ->  (string)
 | TYP_ROW of unit ->  (string) | TYP of unit ->  (string)
 | TYP_SEQ of unit ->  (string) | TYP_TUPLE of unit ->  (string)
 | EX_BIND of unit ->  (string) | EX_BIND_BASE of unit ->  (string)
 | CON_BIND of unit ->  (string) | CONBIND_BASE of unit ->  (string)
 | DAT_BIND of unit ->  (string) | DAT_BIND' of unit ->  (string)
 | TYP_BIND of unit ->  (string) | TYP_BIND' of unit ->  (string)
 | FVAL_BIND of unit ->  (string) | FVALBIND_BASE of unit ->  (string)
 | AT_PAT_LIST of unit ->  (string) | VAL_BIND of unit ->  (string)
 | DEC of unit ->  (string) | DEC' of unit ->  (string)
 | VID_LIST of unit ->  (string)
 | LONG_STR_ID_LIST of unit ->  (string)
 | ASSERTIONS of unit ->  (string) | ASSERT_EXP of unit ->  (string)
 | TYP_VAR_SEQ of unit ->  (string)
 | TYP_VAR_COMMAS of unit ->  (string) | MATCH of unit ->  (string)
 | MRULE of unit ->  (string) | EXP of unit ->  (string)
 | INF_EXP of unit ->  (string) | APP_EXP of unit ->  (string)
 | EXP_ROW of unit ->  (string) | AT_EXP of unit ->  (string)
 | EXP_SEQ of unit ->  (string) | EXP_LIST of unit ->  (string)
 | LONG_ID_NO_EQ of unit ->  (string) | ID_NO_EQ of unit ->  (string)
 | FUN_ID of unit ->  (string) | SIG_ID of unit ->  (string)
 | LONG_STR_ID of unit ->  (string) | STR_ID of unit ->  (string)
 | LAB of unit ->  (string) | LONG_TYP_CON of unit ->  (string)
 | TYP_CON of unit ->  (string) | TYP_VAR of unit ->  (string)
 | LONG_VID of unit ->  (string) | VID of unit ->  (string)
 | CON of unit ->  (string)
 | START of unit ->  ( ( string * (int list * int list * int list) )  option)
end
type svalue = MlyValue.svalue
type result =  ( string * (int list * int list * int list) )  option
end
structure EC=
struct
open LrTable
infix 5 $$
fun x $$ y = y::x
val is_keyword =
fn _ => false
val preferred_change : (term list * term list) list = 
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "INT"
  | (T 2) => "REAL"
  | (T 3) => "WORD"
  | (T 4) => "CHAR"
  | (T 5) => "STRING"
  | (T 6) => "EQUALOP"
  | (T 7) => "TIMES"
  | (T 8) => "SEMICOLON"
  | (T 9) => "COMMA"
  | (T 10) => "DOT"
  | (T 11) => "ARROW"
  | (T 12) => "DARROW"
  | (T 13) => "BAR"
  | (T 14) => "COLON"
  | (T 15) => "COLONGT"
  | (T 16) => "HASH"
  | (T 17) => "LCURLY"
  | (T 18) => "RCURLY"
  | (T 19) => "LBRACK"
  | (T 20) => "RBRACK"
  | (T 21) => "LPAREN"
  | (T 22) => "RPAREN"
  | (T 23) => "IF"
  | (T 24) => "THEN"
  | (T 25) => "ELSE"
  | (T 26) => "WHILE"
  | (T 27) => "DO"
  | (T 28) => "LET"
  | (T 29) => "IN"
  | (T 30) => "END"
  | (T 31) => "ORELSE"
  | (T 32) => "ANDALSO"
  | (T 33) => "HANDLE"
  | (T 34) => "RAISE"
  | (T 35) => "EXCEPTION"
  | (T 36) => "VAL"
  | (T 37) => "AND"
  | (T 38) => "FN"
  | (T 39) => "FUN"
  | (T 40) => "CASE"
  | (T 41) => "OF"
  | (T 42) => "WILD"
  | (T 43) => "OP"
  | (T 44) => "REC"
  | (T 45) => "TYPE"
  | (T 46) => "DATATYPE"
  | (T 47) => "ABSTYPE"
  | (T 48) => "WITH"
  | (T 49) => "WITHTYPE"
  | (T 50) => "AS"
  | (T 51) => "OPEN"
  | (T 52) => "LOCAL"
  | (T 53) => "INFIX"
  | (T 54) => "INFIXR"
  | (T 55) => "NONFIX"
  | (T 56) => "STRUCT"
  | (T 57) => "STRUCTURE"
  | (T 58) => "SIG"
  | (T 59) => "SIGNATURE"
  | (T 60) => "FUNCTOR"
  | (T 61) => "INCLUDE"
  | (T 62) => "WHERE"
  | (T 63) => "EQTYPE"
  | (T 64) => "SHARING"
  | (T 65) => "DOTTED_WILDCARD"
  | (T 66) => "LASSERT"
  | (T 67) => "RASSERT"
  | (T 68) => "REQUIRES"
  | (T 69) => "ENSURES"
  | (T 70) => "SYMBOLS"
  | (T 71) => "QUOTE_ID"
  | (T 72) => "ID"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn _ => MlyValue.VOID
end
val terms : term list = nil
end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (()):arg) =>
case (i392,stack)
of  ( 0, ( ( _, ( MlyValue.PROGRAM PROGRAM1, PROGRAM1left, 
PROGRAM1right)) :: rest671)) => let val  result = MlyValue.START (fn _
 => let val  (PROGRAM as PROGRAM1) = PROGRAM1 ()
 in (SOME (PROGRAM, !final_list_ref))
end)
 in ( LrTable.NT 0, ( result, PROGRAM1left, PROGRAM1right), rest671)

end
|  ( 1, ( rest671)) => let val  result = MlyValue.START (fn _ => (NONE
))
 in ( LrTable.NT 0, ( result, defaultPos, defaultPos), rest671)
end
|  ( 2, ( ( _, ( MlyValue.EOF EOF1, EOF1left, EOF1right)) :: rest671))
 => let val  result = MlyValue.PROGRAM (fn _ => let val  (EOF as EOF1)
 = EOF1 ()
 in (
let
                   val (req, ens, _) = !EOF;
                   val num_list = !new_ref
                 in
                   new_num := 1;
                   new_ref := [];
                   final_list_ref := (req, ens, num_list);
                   ""
                 end
)
end)
 in ( LrTable.NT 84, ( result, EOF1left, EOF1right), rest671)
end
|  ( 3, ( ( _, ( MlyValue.PROGRAM PROGRAM1, _, PROGRAM1right)) :: ( _,
 ( MlyValue.SEMICOLON SEMICOLON1, SEMICOLON1left, _)) :: rest671)) =>
 let val  result = MlyValue.PROGRAM (fn _ => let val  (SEMICOLON as 
SEMICOLON1) = SEMICOLON1 ()
 val  (PROGRAM as PROGRAM1) = PROGRAM1 ()
 in (spacer'([SEMICOLON, PROGRAM]))
end)
 in ( LrTable.NT 84, ( result, SEMICOLON1left, PROGRAM1right), rest671
)
end
|  ( 4, ( ( _, ( MlyValue.PROGRAM PROGRAM1, _, PROGRAM1right)) :: ( _,
 ( MlyValue.EXP EXP1, EXP1left, _)) :: rest671)) => let val  result = 
MlyValue.PROGRAM (fn _ => let val  (EXP as EXP1) = EXP1 ()
 val  (PROGRAM as PROGRAM1) = PROGRAM1 ()
 in (spacer'([EXP, PROGRAM]))
end)
 in ( LrTable.NT 84, ( result, EXP1left, PROGRAM1right), rest671)
end
|  ( 5, ( ( _, ( MlyValue.PROGRAM PROGRAM1, _, PROGRAM1right)) :: ( _,
 ( MlyValue.S_DEC S_DEC1, S_DEC1left, _)) :: rest671)) => let val  
result = MlyValue.PROGRAM (fn _ => let val  (S_DEC as S_DEC1) = S_DEC1
 ()
 val  (PROGRAM as PROGRAM1) = PROGRAM1 ()
 in (spacer'([S_DEC, PROGRAM]))
end)
 in ( LrTable.NT 84, ( result, S_DEC1left, PROGRAM1right), rest671)

end
|  ( 6, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671))
 => let val  result = MlyValue.CON (fn _ => let val  (INT as INT1) = 
INT1 ()
 in (INT)
end)
 in ( LrTable.NT 1, ( result, INT1left, INT1right), rest671)
end
|  ( 7, ( ( _, ( MlyValue.WORD WORD1, WORD1left, WORD1right)) :: 
rest671)) => let val  result = MlyValue.CON (fn _ => let val  (WORD
 as WORD1) = WORD1 ()
 in (WORD)
end)
 in ( LrTable.NT 1, ( result, WORD1left, WORD1right), rest671)
end
|  ( 8, ( ( _, ( MlyValue.REAL REAL1, REAL1left, REAL1right)) :: 
rest671)) => let val  result = MlyValue.CON (fn _ => let val  (REAL
 as REAL1) = REAL1 ()
 in (REAL)
end)
 in ( LrTable.NT 1, ( result, REAL1left, REAL1right), rest671)
end
|  ( 9, ( ( _, ( MlyValue.CHAR CHAR1, CHAR1left, CHAR1right)) :: 
rest671)) => let val  result = MlyValue.CON (fn _ => let val  (CHAR
 as CHAR1) = CHAR1 ()
 in (CHAR)
end)
 in ( LrTable.NT 1, ( result, CHAR1left, CHAR1right), rest671)
end
|  ( 10, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right))
 :: rest671)) => let val  result = MlyValue.CON (fn _ => let val  (
STRING as STRING1) = STRING1 ()
 in (STRING)
end)
 in ( LrTable.NT 1, ( result, STRING1left, STRING1right), rest671)
end
|  ( 11, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.VID (fn _ => let val  (ID as ID1) = ID1 ()
 in (ID)
end)
 in ( LrTable.NT 2, ( result, ID1left, ID1right), rest671)
end
|  ( 12, ( ( _, ( MlyValue.SYMBOLS SYMBOLS1, SYMBOLS1left, 
SYMBOLS1right)) :: rest671)) => let val  result = MlyValue.VID (fn _
 => let val  (SYMBOLS as SYMBOLS1) = SYMBOLS1 ()
 in (SYMBOLS)
end)
 in ( LrTable.NT 2, ( result, SYMBOLS1left, SYMBOLS1right), rest671)

end
|  ( 13, ( ( _, ( MlyValue.EQUALOP EQUALOP1, EQUALOP1left, 
EQUALOP1right)) :: rest671)) => let val  result = MlyValue.VID (fn _
 => let val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 in (EQUALOP)
end)
 in ( LrTable.NT 2, ( result, EQUALOP1left, EQUALOP1right), rest671)

end
|  ( 14, ( ( _, ( MlyValue.TIMES TIMES1, TIMES1left, TIMES1right)) :: 
rest671)) => let val  result = MlyValue.VID (fn _ => let val  (TIMES
 as TIMES1) = TIMES1 ()
 in (TIMES)
end)
 in ( LrTable.NT 2, ( result, TIMES1left, TIMES1right), rest671)
end
|  ( 15, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671)
) => let val  result = MlyValue.LONG_VID (fn _ => let val  (VID as 
VID1) = VID1 ()
 in (VID)
end)
 in ( LrTable.NT 3, ( result, VID1left, VID1right), rest671)
end
|  ( 16, ( ( _, ( MlyValue.LONG_VID LONG_VID1, _, LONG_VID1right)) :: 
( _, ( MlyValue.DOT DOT1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left
, _)) :: rest671)) => let val  result = MlyValue.LONG_VID (fn _ => let
 val  (VID as VID1) = VID1 ()
 val  (DOT as DOT1) = DOT1 ()
 val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (VID ^ DOT ^ LONG_VID)
end)
 in ( LrTable.NT 3, ( result, VID1left, LONG_VID1right), rest671)
end
|  ( 17, ( ( _, ( MlyValue.QUOTE_ID QUOTE_ID1, QUOTE_ID1left, 
QUOTE_ID1right)) :: rest671)) => let val  result = MlyValue.TYP_VAR
 (fn _ => let val  (QUOTE_ID as QUOTE_ID1) = QUOTE_ID1 ()
 in (QUOTE_ID)
end)
 in ( LrTable.NT 4, ( result, QUOTE_ID1left, QUOTE_ID1right), rest671)

end
|  ( 18, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.ALL_IDs (fn _ => let val  (ID as ID1) = 
ID1 ()
 in (ID)
end)
 in ( LrTable.NT 94, ( result, ID1left, ID1right), rest671)
end
|  ( 19, ( ( _, ( MlyValue.SYMBOLS SYMBOLS1, SYMBOLS1left, 
SYMBOLS1right)) :: rest671)) => let val  result = MlyValue.ALL_IDs (fn
 _ => let val  (SYMBOLS as SYMBOLS1) = SYMBOLS1 ()
 in (SYMBOLS)
end)
 in ( LrTable.NT 94, ( result, SYMBOLS1left, SYMBOLS1right), rest671)

end
|  ( 20, ( ( _, ( MlyValue.QID QID1, _, QID1right)) :: ( _, ( 
MlyValue.DOT DOT1, _, _)) :: ( _, ( MlyValue.ALL_IDs ALL_IDs1, 
ALL_IDs1left, _)) :: rest671)) => let val  result = MlyValue.QID (fn _
 => let val  (ALL_IDs as ALL_IDs1) = ALL_IDs1 ()
 val  (DOT as DOT1) = DOT1 ()
 val  (QID as QID1) = QID1 ()
 in (spacer([ALL_IDs, DOT, QID]))
end)
 in ( LrTable.NT 89, ( result, ALL_IDs1left, QID1right), rest671)
end
|  ( 21, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671)
) => let val  result = MlyValue.QID (fn _ => let val  (VID as VID1) = 
VID1 ()
 in (VID)
end)
 in ( LrTable.NT 89, ( result, VID1left, VID1right), rest671)
end
|  ( 22, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.TYP_CON (fn _ => let val  (ID as ID1) = 
ID1 ()
 in (ID)
end)
 in ( LrTable.NT 5, ( result, ID1left, ID1right), rest671)
end
|  ( 23, ( ( _, ( MlyValue.SYMBOLS SYMBOLS1, SYMBOLS1left, 
SYMBOLS1right)) :: rest671)) => let val  result = MlyValue.TYP_CON (fn
 _ => let val  (SYMBOLS as SYMBOLS1) = SYMBOLS1 ()
 in (SYMBOLS)
end)
 in ( LrTable.NT 5, ( result, SYMBOLS1left, SYMBOLS1right), rest671)

end
|  ( 24, ( ( _, ( MlyValue.EQUALOP EQUALOP1, EQUALOP1left, 
EQUALOP1right)) :: rest671)) => let val  result = MlyValue.TYP_CON (fn
 _ => let val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 in (EQUALOP)
end)
 in ( LrTable.NT 5, ( result, EQUALOP1left, EQUALOP1right), rest671)

end
|  ( 25, ( ( _, ( MlyValue.TYP_CON TYP_CON1, TYP_CON1left, 
TYP_CON1right)) :: rest671)) => let val  result = 
MlyValue.LONG_TYP_CON (fn _ => let val  (TYP_CON as TYP_CON1) = 
TYP_CON1 ()
 in (TYP_CON)
end)
 in ( LrTable.NT 6, ( result, TYP_CON1left, TYP_CON1right), rest671)

end
|  ( 26, ( ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, _, 
LONG_TYP_CON1right)) :: ( _, ( MlyValue.DOT DOT1, _, _)) :: ( _, ( 
MlyValue.TYP_CON TYP_CON1, TYP_CON1left, _)) :: rest671)) => let val  
result = MlyValue.LONG_TYP_CON (fn _ => let val  (TYP_CON as TYP_CON1)
 = TYP_CON1 ()
 val  (DOT as DOT1) = DOT1 ()
 val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 in (TYP_CON ^ DOT ^ LONG_TYP_CON)
end)
 in ( LrTable.NT 6, ( result, TYP_CON1left, LONG_TYP_CON1right), 
rest671)
end
|  ( 27, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.LAB (fn _ => let val  (ID as ID1) = ID1 ()
 in (ID)
end)
 in ( LrTable.NT 7, ( result, ID1left, ID1right), rest671)
end
|  ( 28, ( ( _, ( MlyValue.SYMBOLS SYMBOLS1, SYMBOLS1left, 
SYMBOLS1right)) :: rest671)) => let val  result = MlyValue.LAB (fn _
 => let val  (SYMBOLS as SYMBOLS1) = SYMBOLS1 ()
 in (SYMBOLS)
end)
 in ( LrTable.NT 7, ( result, SYMBOLS1left, SYMBOLS1right), rest671)

end
|  ( 29, ( ( _, ( MlyValue.EQUALOP EQUALOP1, EQUALOP1left, 
EQUALOP1right)) :: rest671)) => let val  result = MlyValue.LAB (fn _
 => let val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 in (EQUALOP)
end)
 in ( LrTable.NT 7, ( result, EQUALOP1left, EQUALOP1right), rest671)

end
|  ( 30, ( ( _, ( MlyValue.TIMES TIMES1, TIMES1left, TIMES1right)) :: 
rest671)) => let val  result = MlyValue.LAB (fn _ => let val  (TIMES
 as TIMES1) = TIMES1 ()
 in (TIMES)
end)
 in ( LrTable.NT 7, ( result, TIMES1left, TIMES1right), rest671)
end
|  ( 31, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671)
) => let val  result = MlyValue.LAB (fn _ => let val  (INT as INT1) = 
INT1 ()
 in (
if sub(INT, 0) = #"~" orelse sub(INT,0) = #"0" then 
            ((print "Error: Record Var cannot start with 0 or ~"); 
              raise LabError)
            else INT
)
end)
 in ( LrTable.NT 7, ( result, INT1left, INT1right), rest671)
end
|  ( 32, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.FUN_ID (fn _ => let val  (ID as ID1) = ID1
 ()
 in (ID)
end)
 in ( LrTable.NT 11, ( result, ID1left, ID1right), rest671)
end
|  ( 33, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.STR_ID (fn _ => let val  (ID as ID1) = ID1
 ()
 in (ID)
end)
 in ( LrTable.NT 8, ( result, ID1left, ID1right), rest671)
end
|  ( 34, ( ( _, ( MlyValue.STR_ID STR_ID1, STR_ID1left, STR_ID1right))
 :: rest671)) => let val  result = MlyValue.LONG_STR_ID (fn _ => let
 val  (STR_ID as STR_ID1) = STR_ID1 ()
 in (STR_ID)
end)
 in ( LrTable.NT 9, ( result, STR_ID1left, STR_ID1right), rest671)
end
|  ( 35, ( ( _, ( MlyValue.LONG_STR_ID LONG_STR_ID1, _, 
LONG_STR_ID1right)) :: ( _, ( MlyValue.DOT DOT1, _, _)) :: ( _, ( 
MlyValue.STR_ID STR_ID1, STR_ID1left, _)) :: rest671)) => let val  
result = MlyValue.LONG_STR_ID (fn _ => let val  (STR_ID as STR_ID1) = 
STR_ID1 ()
 val  (DOT as DOT1) = DOT1 ()
 val  (LONG_STR_ID as LONG_STR_ID1) = LONG_STR_ID1 ()
 in (STR_ID ^ DOT ^ LONG_STR_ID)
end)
 in ( LrTable.NT 9, ( result, STR_ID1left, LONG_STR_ID1right), rest671
)
end
|  ( 36, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.SIG_ID (fn _ => let val  (ID as ID1) = ID1
 ()
 in (ID)
end)
 in ( LrTable.NT 10, ( result, ID1left, ID1right), rest671)
end
|  ( 37, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671)) =>
 let val  result = MlyValue.ID_NO_EQ (fn _ => let val  (ID as ID1) = 
ID1 ()
 in (ID)
end)
 in ( LrTable.NT 12, ( result, ID1left, ID1right), rest671)
end
|  ( 38, ( ( _, ( MlyValue.SYMBOLS SYMBOLS1, SYMBOLS1left, 
SYMBOLS1right)) :: rest671)) => let val  result = MlyValue.ID_NO_EQ
 (fn _ => let val  (SYMBOLS as SYMBOLS1) = SYMBOLS1 ()
 in (SYMBOLS)
end)
 in ( LrTable.NT 12, ( result, SYMBOLS1left, SYMBOLS1right), rest671)

end
|  ( 39, ( ( _, ( MlyValue.TIMES TIMES1, TIMES1left, TIMES1right)) :: 
rest671)) => let val  result = MlyValue.ID_NO_EQ (fn _ => let val  (
TIMES as TIMES1) = TIMES1 ()
 in (TIMES)
end)
 in ( LrTable.NT 12, ( result, TIMES1left, TIMES1right), rest671)
end
|  ( 40, ( ( _, ( MlyValue.ID_NO_EQ ID_NO_EQ1, ID_NO_EQ1left, 
ID_NO_EQ1right)) :: rest671)) => let val  result = 
MlyValue.LONG_ID_NO_EQ (fn _ => let val  (ID_NO_EQ as ID_NO_EQ1) = 
ID_NO_EQ1 ()
 in (ID_NO_EQ)
end)
 in ( LrTable.NT 13, ( result, ID_NO_EQ1left, ID_NO_EQ1right), rest671
)
end
|  ( 41, ( ( _, ( MlyValue.LONG_ID_NO_EQ LONG_ID_NO_EQ1, _, 
LONG_ID_NO_EQ1right)) :: ( _, ( MlyValue.DOT DOT1, _, _)) :: ( _, ( 
MlyValue.ID_NO_EQ ID_NO_EQ1, ID_NO_EQ1left, _)) :: rest671)) => let
 val  result = MlyValue.LONG_ID_NO_EQ (fn _ => let val  (ID_NO_EQ as 
ID_NO_EQ1) = ID_NO_EQ1 ()
 val  (DOT as DOT1) = DOT1 ()
 val  (LONG_ID_NO_EQ as LONG_ID_NO_EQ1) = LONG_ID_NO_EQ1 ()
 in (ID_NO_EQ ^ DOT ^ LONG_ID_NO_EQ)
end)
 in ( LrTable.NT 13, ( result, ID_NO_EQ1left, LONG_ID_NO_EQ1right), 
rest671)
end
|  ( 42, ( ( _, ( MlyValue.EXP EXP1, EXP1left, EXP1right)) :: rest671)
) => let val  result = MlyValue.EXP_LIST (fn _ => let val  (EXP as 
EXP1) = EXP1 ()
 in (EXP)
end)
 in ( LrTable.NT 14, ( result, EXP1left, EXP1right), rest671)
end
|  ( 43, ( ( _, ( MlyValue.EXP_LIST EXP_LIST1, _, EXP_LIST1right)) :: 
( _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.EXP EXP1, 
EXP1left, _)) :: rest671)) => let val  result = MlyValue.EXP_LIST (fn
 _ => let val  (EXP as EXP1) = EXP1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (EXP_LIST as EXP_LIST1) = EXP_LIST1 ()
 in (EXP ^ " " ^ COMMA ^ " " ^ EXP_LIST)
end)
 in ( LrTable.NT 14, ( result, EXP1left, EXP_LIST1right), rest671)
end
|  ( 44, ( ( _, ( MlyValue.EXP EXP2, _, EXP2right)) :: ( _, ( 
MlyValue.SEMICOLON SEMICOLON1, _, _)) :: ( _, ( MlyValue.EXP EXP1, 
EXP1left, _)) :: rest671)) => let val  result = MlyValue.EXP_SEQ (fn _
 => let val  EXP1 = EXP1 ()
 val  (SEMICOLON as SEMICOLON1) = SEMICOLON1 ()
 val  EXP2 = EXP2 ()
 in (EXP1 ^ " " ^ SEMICOLON ^ " " ^ EXP2)
end)
 in ( LrTable.NT 15, ( result, EXP1left, EXP2right), rest671)
end
|  ( 45, ( ( _, ( MlyValue.EXP_SEQ EXP_SEQ1, _, EXP_SEQ1right)) :: ( _
, ( MlyValue.SEMICOLON SEMICOLON1, _, _)) :: ( _, ( MlyValue.EXP EXP1,
 EXP1left, _)) :: rest671)) => let val  result = MlyValue.EXP_SEQ (fn
 _ => let val  (EXP as EXP1) = EXP1 ()
 val  (SEMICOLON as SEMICOLON1) = SEMICOLON1 ()
 val  (EXP_SEQ as EXP_SEQ1) = EXP_SEQ1 ()
 in (EXP ^ " " ^ SEMICOLON ^ " " ^ EXP_SEQ)
end)
 in ( LrTable.NT 15, ( result, EXP1left, EXP_SEQ1right), rest671)
end
|  ( 46, ( ( _, ( MlyValue.CON CON1, CON1left, CON1right)) :: rest671)
) => let val  result = MlyValue.AT_EXP (fn _ => let val  (CON as CON1)
 = CON1 ()
 in (CON)
end)
 in ( LrTable.NT 16, ( result, CON1left, CON1right), rest671)
end
|  ( 47, ( ( _, ( MlyValue.LONG_VID LONG_VID1, LONG_VID1left, 
LONG_VID1right)) :: rest671)) => let val  result = MlyValue.AT_EXP (fn
 _ => let val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (LONG_VID)
end)
 in ( LrTable.NT 16, ( result, LONG_VID1left, LONG_VID1right), rest671
)
end
|  ( 48, ( ( _, ( MlyValue.LONG_VID LONG_VID1, _, LONG_VID1right)) :: 
( _, ( MlyValue.OP OP1, OP1left, _)) :: rest671)) => let val  result =
 MlyValue.AT_EXP (fn _ => let val  (OP as OP1) = OP1 ()
 val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (OP ^ " " ^ LONG_VID)
end)
 in ( LrTable.NT 16, ( result, OP1left, LONG_VID1right), rest671)
end
|  ( 49, ( ( _, ( MlyValue.RCURLY RCURLY1, _, RCURLY1right)) :: ( _, (
 MlyValue.LCURLY LCURLY1, LCURLY1left, _)) :: rest671)) => let val  
result = MlyValue.AT_EXP (fn _ => let val  (LCURLY as LCURLY1) = 
LCURLY1 ()
 val  (RCURLY as RCURLY1) = RCURLY1 ()
 in (spacer'([LCURLY, RCURLY]))
end)
 in ( LrTable.NT 16, ( result, LCURLY1left, RCURLY1right), rest671)

end
|  ( 50, ( ( _, ( MlyValue.RCURLY RCURLY1, _, RCURLY1right)) :: ( _, (
 MlyValue.EXP_ROW EXP_ROW1, _, _)) :: ( _, ( MlyValue.LCURLY LCURLY1, 
LCURLY1left, _)) :: rest671)) => let val  result = MlyValue.AT_EXP (fn
 _ => let val  (LCURLY as LCURLY1) = LCURLY1 ()
 val  (EXP_ROW as EXP_ROW1) = EXP_ROW1 ()
 val  (RCURLY as RCURLY1) = RCURLY1 ()
 in (spacer'([LCURLY, EXP_ROW, RCURLY]))
end)
 in ( LrTable.NT 16, ( result, LCURLY1left, RCURLY1right), rest671)

end
|  ( 51, ( ( _, ( MlyValue.LAB LAB1, _, LAB1right)) :: ( _, ( 
MlyValue.HASH HASH1, HASH1left, _)) :: rest671)) => let val  result = 
MlyValue.AT_EXP (fn _ => let val  (HASH as HASH1) = HASH1 ()
 val  (LAB as LAB1) = LAB1 ()
 in (HASH ^ " " ^ LAB)
end)
 in ( LrTable.NT 16, ( result, HASH1left, LAB1right), rest671)
end
|  ( 52, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, (
 MlyValue.LPAREN LPAREN1, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.AT_EXP (fn _ => let val  (LPAREN as LPAREN1) = 
LPAREN1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (LPAREN ^ " " ^ RPAREN)
end)
 in ( LrTable.NT 16, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 53, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, (
 MlyValue.EXP_LIST EXP_LIST1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1
, LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.AT_EXP
 (fn _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (EXP_LIST as EXP_LIST1) = EXP_LIST1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, EXP_LIST, RPAREN]))
end)
 in ( LrTable.NT 16, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 54, ( ( _, ( MlyValue.RBRACK RBRACK1, _, RBRACK1right)) :: ( _, (
 MlyValue.LBRACK LBRACK1, LBRACK1left, _)) :: rest671)) => let val  
result = MlyValue.AT_EXP (fn _ => let val  (LBRACK as LBRACK1) = 
LBRACK1 ()
 val  (RBRACK as RBRACK1) = RBRACK1 ()
 in (LBRACK ^ " " ^ RBRACK)
end)
 in ( LrTable.NT 16, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 55, ( ( _, ( MlyValue.RBRACK RBRACK1, _, RBRACK1right)) :: ( _, (
 MlyValue.EXP_LIST EXP_LIST1, _, _)) :: ( _, ( MlyValue.LBRACK LBRACK1
, LBRACK1left, _)) :: rest671)) => let val  result = MlyValue.AT_EXP
 (fn _ => let val  (LBRACK as LBRACK1) = LBRACK1 ()
 val  (EXP_LIST as EXP_LIST1) = EXP_LIST1 ()
 val  (RBRACK as RBRACK1) = RBRACK1 ()
 in (spacer'([LBRACK, EXP_LIST, RBRACK]))
end)
 in ( LrTable.NT 16, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 56, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, (
 MlyValue.EXP_SEQ EXP_SEQ1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.AT_EXP (fn
 _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (EXP_SEQ as EXP_SEQ1) = EXP_SEQ1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, EXP_SEQ, RPAREN]))
end)
 in ( LrTable.NT 16, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 57, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.EXP EXP1, _, _)) :: ( _, ( MlyValue.IN IN1, _, _)) :: ( _, ( 
MlyValue.DEC DEC1, _, _)) :: ( _, ( MlyValue.LET LET1, LET1left, _))
 :: rest671)) => let val  result = MlyValue.AT_EXP (fn _ => let val  (
LET as LET1) = LET1 ()
 val  (DEC as DEC1) = DEC1 ()
 val  (IN as IN1) = IN1 ()
 val  (EXP as EXP1) = EXP1 ()
 val  (END as END1) = END1 ()
 in (spacer'([LET, DEC, IN, EXP, END]))
end)
 in ( LrTable.NT 16, ( result, LET1left, END1right), rest671)
end
|  ( 58, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.EXP_SEQ EXP_SEQ1, _, _)) :: ( _, ( MlyValue.IN IN1, _, _)) ::
 ( _, ( MlyValue.DEC DEC1, _, _)) :: ( _, ( MlyValue.LET LET1, 
LET1left, _)) :: rest671)) => let val  result = MlyValue.AT_EXP (fn _
 => let val  (LET as LET1) = LET1 ()
 val  (DEC as DEC1) = DEC1 ()
 val  (IN as IN1) = IN1 ()
 val  (EXP_SEQ as EXP_SEQ1) = EXP_SEQ1 ()
 val  (END as END1) = END1 ()
 in (spacer'([LET, DEC, IN, EXP_SEQ, END]))
end)
 in ( LrTable.NT 16, ( result, LET1left, END1right), rest671)
end
|  ( 59, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.LAB LAB1, 
LAB1left, _)) :: rest671)) => let val  result = MlyValue.EXP_ROW (fn _
 => let val  (LAB as LAB1) = LAB1 ()
 val  EQUALOP1 = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (LAB ^ "=" ^ EXP)
end)
 in ( LrTable.NT 17, ( result, LAB1left, EXP1right), rest671)
end
|  ( 60, ( ( _, ( MlyValue.EXP_ROW EXP_ROW1, _, EXP_ROW1right)) :: ( _
, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.EXP EXP1, _, _))
 :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.LAB 
LAB1, LAB1left, _)) :: rest671)) => let val  result = MlyValue.EXP_ROW
 (fn _ => let val  (LAB as LAB1) = LAB1 ()
 val  EQUALOP1 = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (EXP_ROW as EXP_ROW1) = EXP_ROW1 ()
 in (LAB ^ "=" ^ EXP ^ " " ^ COMMA ^ " " ^ EXP_ROW)
end)
 in ( LrTable.NT 17, ( result, LAB1left, EXP_ROW1right), rest671)
end
|  ( 61, ( ( _, ( MlyValue.AT_EXP AT_EXP1, AT_EXP1left, AT_EXP1right))
 :: rest671)) => let val  result = MlyValue.APP_EXP (fn _ => let val 
 (AT_EXP as AT_EXP1) = AT_EXP1 ()
 in (AT_EXP)
end)
 in ( LrTable.NT 18, ( result, AT_EXP1left, AT_EXP1right), rest671)

end
|  ( 62, ( ( _, ( MlyValue.AT_EXP AT_EXP1, _, AT_EXP1right)) :: ( _, (
 MlyValue.APP_EXP APP_EXP1, APP_EXP1left, _)) :: rest671)) => let val 
 result = MlyValue.APP_EXP (fn _ => let val  (APP_EXP as APP_EXP1) = 
APP_EXP1 ()
 val  (AT_EXP as AT_EXP1) = AT_EXP1 ()
 in (APP_EXP ^ " " ^ AT_EXP)
end)
 in ( LrTable.NT 18, ( result, APP_EXP1left, AT_EXP1right), rest671)

end
|  ( 63, ( ( _, ( MlyValue.APP_EXP APP_EXP1, APP_EXP1left, 
APP_EXP1right)) :: rest671)) => let val  result = MlyValue.INF_EXP (fn
 _ => let val  (APP_EXP as APP_EXP1) = APP_EXP1 ()
 in (APP_EXP)
end)
 in ( LrTable.NT 19, ( result, APP_EXP1left, APP_EXP1right), rest671)

end
|  ( 64, ( ( _, ( MlyValue.INF_EXP INF_EXP2, _, INF_EXP2right)) :: ( _
, ( MlyValue.VID VID1, _, _)) :: ( _, ( MlyValue.INF_EXP INF_EXP1, 
INF_EXP1left, _)) :: rest671)) => let val  result = MlyValue.INF_EXP
 (fn _ => let val  INF_EXP1 = INF_EXP1 ()
 val  (VID as VID1) = VID1 ()
 val  INF_EXP2 = INF_EXP2 ()
 in (INF_EXP1 ^ " " ^ VID ^ " " ^ INF_EXP2)
end)
 in ( LrTable.NT 19, ( result, INF_EXP1left, INF_EXP2right), rest671)

end
|  ( 65, ( ( _, ( MlyValue.INF_EXP INF_EXP1, INF_EXP1left, 
INF_EXP1right)) :: rest671)) => let val  result = MlyValue.EXP (fn _
 => let val  (INF_EXP as INF_EXP1) = INF_EXP1 ()
 in (INF_EXP)
end)
 in ( LrTable.NT 20, ( result, INF_EXP1left, INF_EXP1right), rest671)

end
|  ( 66, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.EXP EXP1, EXP1left, _
)) :: rest671)) => let val  result = MlyValue.EXP (fn _ => let val  (
EXP as EXP1) = EXP1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([EXP, COLON, TYP]))
end)
 in ( LrTable.NT 20, ( result, EXP1left, TYP1right), rest671)
end
|  ( 67, ( ( _, ( MlyValue.EXP EXP2, _, EXP2right)) :: ( _, ( 
MlyValue.ANDALSO ANDALSO1, _, _)) :: ( _, ( MlyValue.EXP EXP1, 
EXP1left, _)) :: rest671)) => let val  result = MlyValue.EXP (fn _ =>
 let val  EXP1 = EXP1 ()
 val  (ANDALSO as ANDALSO1) = ANDALSO1 ()
 val  EXP2 = EXP2 ()
 in (spacer'([EXP1, ANDALSO, EXP2]))
end)
 in ( LrTable.NT 20, ( result, EXP1left, EXP2right), rest671)
end
|  ( 68, ( ( _, ( MlyValue.EXP EXP2, _, EXP2right)) :: ( _, ( 
MlyValue.ORELSE ORELSE1, _, _)) :: ( _, ( MlyValue.EXP EXP1, EXP1left,
 _)) :: rest671)) => let val  result = MlyValue.EXP (fn _ => let val  
EXP1 = EXP1 ()
 val  (ORELSE as ORELSE1) = ORELSE1 ()
 val  EXP2 = EXP2 ()
 in (spacer'([EXP1, ORELSE, EXP2]))
end)
 in ( LrTable.NT 20, ( result, EXP1left, EXP2right), rest671)
end
|  ( 69, ( ( _, ( MlyValue.MATCH MATCH1, _, MATCH1right)) :: ( _, ( 
MlyValue.HANDLE HANDLE1, _, _)) :: ( _, ( MlyValue.EXP EXP1, EXP1left,
 _)) :: rest671)) => let val  result = MlyValue.EXP (fn _ => let val 
 (EXP as EXP1) = EXP1 ()
 val  (HANDLE as HANDLE1) = HANDLE1 ()
 val  (MATCH as MATCH1) = MATCH1 ()
 in (spacer'([EXP, HANDLE, MATCH]))
end)
 in ( LrTable.NT 20, ( result, EXP1left, MATCH1right), rest671)
end
|  ( 70, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.RAISE RAISE1, RAISE1left, _)) :: rest671)) => let val  result
 = MlyValue.EXP (fn _ => let val  (RAISE as RAISE1) = RAISE1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (spacer'([RAISE, EXP]))
end)
 in ( LrTable.NT 20, ( result, RAISE1left, EXP1right), rest671)
end
|  ( 71, ( ( _, ( MlyValue.EXP EXP3, _, EXP3right)) :: ( _, ( 
MlyValue.ELSE ELSE1, _, _)) :: ( _, ( MlyValue.EXP EXP2, _, _)) :: ( _
, ( MlyValue.THEN THEN1, _, _)) :: ( _, ( MlyValue.EXP EXP1, _, _)) ::
 ( _, ( MlyValue.IF IF1, IF1left, _)) :: rest671)) => let val  result
 = MlyValue.EXP (fn _ => let val  (IF as IF1) = IF1 ()
 val  EXP1 = EXP1 ()
 val  (THEN as THEN1) = THEN1 ()
 val  EXP2 = EXP2 ()
 val  (ELSE as ELSE1) = ELSE1 ()
 val  EXP3 = EXP3 ()
 in (spacer'([IF, EXP1, THEN, EXP2, ELSE, EXP3]))
end)
 in ( LrTable.NT 20, ( result, IF1left, EXP3right), rest671)
end
|  ( 72, ( ( _, ( MlyValue.EXP EXP2, _, EXP2right)) :: ( _, ( 
MlyValue.DO DO1, _, _)) :: ( _, ( MlyValue.EXP EXP1, _, _)) :: ( _, ( 
MlyValue.WHILE WHILE1, WHILE1left, _)) :: rest671)) => let val  result
 = MlyValue.EXP (fn _ => let val  (WHILE as WHILE1) = WHILE1 ()
 val  EXP1 = EXP1 ()
 val  (DO as DO1) = DO1 ()
 val  EXP2 = EXP2 ()
 in (spacer'([WHILE, EXP1, DO, EXP2]))
end)
 in ( LrTable.NT 20, ( result, WHILE1left, EXP2right), rest671)
end
|  ( 73, ( ( _, ( MlyValue.MATCH MATCH1, _, MATCH1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.EXP EXP1, _, _)) :: ( _, ( 
MlyValue.CASE CASE1, CASE1left, _)) :: rest671)) => let val  result = 
MlyValue.EXP (fn _ => let val  (CASE as CASE1) = CASE1 ()
 val  (EXP as EXP1) = EXP1 ()
 val  (OF as OF1) = OF1 ()
 val  (MATCH as MATCH1) = MATCH1 ()
 in (spacer'([CASE, EXP, OF, MATCH]))
end)
 in ( LrTable.NT 20, ( result, CASE1left, MATCH1right), rest671)
end
|  ( 74, ( ( _, ( MlyValue.MATCH MATCH1, _, MATCH1right)) :: ( _, ( 
MlyValue.FN FN1, FN1left, _)) :: rest671)) => let val  result = 
MlyValue.EXP (fn _ => let val  (FN as FN1) = FN1 ()
 val  (MATCH as MATCH1) = MATCH1 ()
 in (spacer'([FN, MATCH]))
end)
 in ( LrTable.NT 20, ( result, FN1left, MATCH1right), rest671)
end
|  ( 75, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.DARROW DARROW1, _, _)) :: ( _, ( MlyValue.PAT PAT1, PAT1left,
 _)) :: rest671)) => let val  result = MlyValue.MRULE (fn _ => let
 val  (PAT as PAT1) = PAT1 ()
 val  (DARROW as DARROW1) = DARROW1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (spacer'([PAT, DARROW, EXP]))
end)
 in ( LrTable.NT 21, ( result, PAT1left, EXP1right), rest671)
end
|  ( 76, ( ( _, ( MlyValue.MRULE MRULE1, MRULE1left, MRULE1right)) :: 
rest671)) => let val  result = MlyValue.MATCH (fn _ => let val  (MRULE
 as MRULE1) = MRULE1 ()
 in (MRULE)
end)
 in ( LrTable.NT 22, ( result, MRULE1left, MRULE1right), rest671)
end
|  ( 77, ( ( _, ( MlyValue.MATCH MATCH1, _, MATCH1right)) :: ( _, ( 
MlyValue.BAR BAR1, _, _)) :: ( _, ( MlyValue.MRULE MRULE1, MRULE1left,
 _)) :: rest671)) => let val  result = MlyValue.MATCH (fn _ => let
 val  (MRULE as MRULE1) = MRULE1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (MATCH as MATCH1) = MATCH1 ()
 in (MRULE ^ "" ^ BAR ^ " " ^ MATCH)
end)
 in ( LrTable.NT 22, ( result, MRULE1left, MATCH1right), rest671)
end
|  ( 78, ( ( _, ( MlyValue.TYP_VAR TYP_VAR1, TYP_VAR1left, 
TYP_VAR1right)) :: rest671)) => let val  result = 
MlyValue.TYP_VAR_COMMAS (fn _ => let val  (TYP_VAR as TYP_VAR1) = 
TYP_VAR1 ()
 in (TYP_VAR)
end)
 in ( LrTable.NT 23, ( result, TYP_VAR1left, TYP_VAR1right), rest671)

end
|  ( 79, ( ( _, ( MlyValue.TYP_VAR_COMMAS TYP_VAR_COMMAS1, _, 
TYP_VAR_COMMAS1right)) :: ( _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _,
 ( MlyValue.TYP_VAR TYP_VAR1, TYP_VAR1left, _)) :: rest671)) => let
 val  result = MlyValue.TYP_VAR_COMMAS (fn _ => let val  (TYP_VAR as 
TYP_VAR1) = TYP_VAR1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (TYP_VAR_COMMAS as TYP_VAR_COMMAS1) = TYP_VAR_COMMAS1 ()
 in (TYP_VAR ^ " " ^ COMMA ^ " " ^ TYP_VAR_COMMAS)
end)
 in ( LrTable.NT 23, ( result, TYP_VAR1left, TYP_VAR_COMMAS1right), 
rest671)
end
|  ( 80, ( ( _, ( MlyValue.TYP_VAR TYP_VAR1, TYP_VAR1left, 
TYP_VAR1right)) :: rest671)) => let val  result = MlyValue.TYP_VAR_SEQ
 (fn _ => let val  (TYP_VAR as TYP_VAR1) = TYP_VAR1 ()
 in (TYP_VAR)
end)
 in ( LrTable.NT 24, ( result, TYP_VAR1left, TYP_VAR1right), rest671)

end
|  ( 81, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, (
 MlyValue.TYP_VAR_COMMAS TYP_VAR_COMMAS1, _, _)) :: ( _, ( 
MlyValue.LPAREN LPAREN1, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.TYP_VAR_SEQ (fn _ => let val  (LPAREN as LPAREN1) = 
LPAREN1 ()
 val  (TYP_VAR_COMMAS as TYP_VAR_COMMAS1) = TYP_VAR_COMMAS1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (LPAREN ^ " " ^ TYP_VAR_COMMAS ^ " " ^ RPAREN)
end)
 in ( LrTable.NT 24, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 82, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.REQUIRES REQUIRES1, 
REQUIRES1left, _)) :: rest671)) => let val  result = 
MlyValue.ASSERT_EXP (fn _ => let val  REQUIRES1 = REQUIRES1 ()
 val  COLON1 = COLON1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (
(let
                                      val ss = !Stack
                                      val ss' = push (ss, REQ (EXP))
                                    in
                                      Stack := ss'
                                    end); ""
)
end)
 in ( LrTable.NT 25, ( result, REQUIRES1left, EXP1right), rest671)
end
|  ( 83, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.ENSURES ENSURES1, 
ENSURES1left, _)) :: rest671)) => let val  result = 
MlyValue.ASSERT_EXP (fn _ => let val  ENSURES1 = ENSURES1 ()
 val  COLON1 = COLON1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (
(let
                                     val ss = !Stack
                                     val ss' = push (ss, ENS (EXP))
                                   in
                                     Stack := ss'
                                   end); ""
)
end)
 in ( LrTable.NT 25, ( result, ENSURES1left, EXP1right), rest671)
end
|  ( 84, ( ( _, ( MlyValue.EXP EXP2, _, EXP2right)) :: ( _, ( 
MlyValue.COLON COLON2, _, _)) :: ( _, ( MlyValue.ENSURES ENSURES1, _,
 _)) :: ( _, ( MlyValue.EXP EXP1, _, _)) :: ( _, ( MlyValue.COLON 
COLON1, _, _)) :: ( _, ( MlyValue.REQUIRES REQUIRES1, REQUIRES1left, _
)) :: rest671)) => let val  result = MlyValue.ASSERT_EXP (fn _ => let
 val  REQUIRES1 = REQUIRES1 ()
 val  COLON1 = COLON1 ()
 val  EXP1 = EXP1 ()
 val  ENSURES1 = ENSURES1 ()
 val  COLON2 = COLON2 ()
 val  EXP2 = EXP2 ()
 in (
(let
                                                        val ss = !Stack
                                                        val ss' = push (ss, BOTH (EXP1, EXP2))
                                                      in
                                                        Stack := ss'
                                                      end); ""
)
end)
 in ( LrTable.NT 25, ( result, REQUIRES1left, EXP2right), rest671)
end
|  ( 85, ( ( _, ( MlyValue.RASSERT RASSERT1, _, RASSERT1right)) :: ( _
, ( MlyValue.ASSERT_EXP ASSERT_EXP1, _, _)) :: ( _, ( MlyValue.LASSERT
 LASSERT1, LASSERT1left, _)) :: rest671)) => let val  result = 
MlyValue.ASSERTIONS (fn _ => let val  LASSERT1 = LASSERT1 ()
 val  ASSERT_EXP1 = ASSERT_EXP1 ()
 val  RASSERT1 = RASSERT1 ()
 in ("")
end)
 in ( LrTable.NT 26, ( result, LASSERT1left, RASSERT1right), rest671)

end
|  ( 86, ( ( _, ( MlyValue.LONG_STR_ID LONG_STR_ID1, LONG_STR_ID1left,
 LONG_STR_ID1right)) :: rest671)) => let val  result = 
MlyValue.LONG_STR_ID_LIST (fn _ => let val  (LONG_STR_ID as 
LONG_STR_ID1) = LONG_STR_ID1 ()
 in (LONG_STR_ID)
end)
 in ( LrTable.NT 27, ( result, LONG_STR_ID1left, LONG_STR_ID1right), 
rest671)
end
|  ( 87, ( ( _, ( MlyValue.LONG_STR_ID_LIST LONG_STR_ID_LIST1, _, 
LONG_STR_ID_LIST1right)) :: ( _, ( MlyValue.LONG_STR_ID LONG_STR_ID1, 
LONG_STR_ID1left, _)) :: rest671)) => let val  result = 
MlyValue.LONG_STR_ID_LIST (fn _ => let val  (LONG_STR_ID as 
LONG_STR_ID1) = LONG_STR_ID1 ()
 val  (LONG_STR_ID_LIST as LONG_STR_ID_LIST1) = LONG_STR_ID_LIST1 ()
 in (spacer'([LONG_STR_ID, LONG_STR_ID_LIST]))
end)
 in ( LrTable.NT 27, ( result, LONG_STR_ID1left, 
LONG_STR_ID_LIST1right), rest671)
end
|  ( 88, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671)
) => let val  result = MlyValue.VID_LIST (fn _ => let val  (VID as 
VID1) = VID1 ()
 in (VID)
end)
 in ( LrTable.NT 28, ( result, VID1left, VID1right), rest671)
end
|  ( 89, ( ( _, ( MlyValue.VID_LIST VID_LIST1, _, VID_LIST1right)) :: 
( _, ( MlyValue.VID VID1, VID1left, _)) :: rest671)) => let val  
result = MlyValue.VID_LIST (fn _ => let val  (VID as VID1) = VID1 ()
 val  (VID_LIST as VID_LIST1) = VID_LIST1 ()
 in (VID ^ " " ^ VID_LIST)
end)
 in ( LrTable.NT 28, ( result, VID1left, VID_LIST1right), rest671)
end
|  ( 90, ( ( _, ( MlyValue.VAL_BIND VAL_BIND1, _, VAL_BIND1right)) :: 
( _, ( MlyValue.VAL VAL1, VAL1left, _)) :: rest671)) => let val  
result = MlyValue.DEC' (fn _ => let val  (VAL as VAL1) = VAL1 ()
 val  (VAL_BIND as VAL_BIND1) = VAL_BIND1 ()
 in (spacer'(["\n\n", VAL, VAL_BIND]))
end)
 in ( LrTable.NT 29, ( result, VAL1left, VAL_BIND1right), rest671)
end
|  ( 91, ( ( _, ( MlyValue.VAL_BIND VAL_BIND1, _, VAL_BIND1right)) :: 
( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, _, _)) :: ( _, ( 
MlyValue.VAL VAL1, VAL1left, _)) :: rest671)) => let val  result = 
MlyValue.DEC' (fn _ => let val  (VAL as VAL1) = VAL1 ()
 val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = TYP_VAR_SEQ1 ()
 val  (VAL_BIND as VAL_BIND1) = VAL_BIND1 ()
 in (spacer'(["\n\n", VAL, TYP_VAR_SEQ, VAL_BIND]))
end)
 in ( LrTable.NT 29, ( result, VAL1left, VAL_BIND1right), rest671)
end
|  ( 92, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.FUN FUN1, _, _)) :: ( _, ( MlyValue.ASSERTIONS 
ASSERTIONS1, ASSERTIONS1left, _)) :: rest671)) => let val  result = 
MlyValue.DEC' (fn _ => let val  ASSERTIONS1 = ASSERTIONS1 ()
 val  (FUN as FUN1) = FUN1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (spacer'(["\n\n", FUN, FVAL_BIND]))
end)
 in ( LrTable.NT 29, ( result, ASSERTIONS1left, FVAL_BIND1right), 
rest671)
end
|  ( 93, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, _, _)) :: ( _, ( 
MlyValue.FUN FUN1, _, _)) :: ( _, ( MlyValue.ASSERTIONS ASSERTIONS1, 
ASSERTIONS1left, _)) :: rest671)) => let val  result = MlyValue.DEC'
 (fn _ => let val  ASSERTIONS1 = ASSERTIONS1 ()
 val  (FUN as FUN1) = FUN1 ()
 val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = TYP_VAR_SEQ1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (spacer'(["\n\n", FUN, TYP_VAR_SEQ, FVAL_BIND]))
end)
 in ( LrTable.NT 29, ( result, ASSERTIONS1left, FVAL_BIND1right), 
rest671)
end
|  ( 94, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.FUN FUN1, FUN1left, _)) :: rest671)) => let val  
result = MlyValue.DEC' (fn _ => let val  (FUN as FUN1) = FUN1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (spacer'(["\n\n", FUN, FVAL_BIND]))
end)
 in ( LrTable.NT 29, ( result, FUN1left, FVAL_BIND1right), rest671)

end
|  ( 95, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, _, _)) :: ( _, ( 
MlyValue.FUN FUN1, FUN1left, _)) :: rest671)) => let val  result = 
MlyValue.DEC' (fn _ => let val  (FUN as FUN1) = FUN1 ()
 val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = TYP_VAR_SEQ1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (spacer'(["\n\n", FUN, TYP_VAR_SEQ, FVAL_BIND]))
end)
 in ( LrTable.NT 29, ( result, FUN1left, FVAL_BIND1right), rest671)

end
|  ( 96, ( ( _, ( MlyValue.TYP_BIND TYP_BIND1, _, TYP_BIND1right)) :: 
( _, ( MlyValue.TYPE TYPE1, TYPE1left, _)) :: rest671)) => let val  
result = MlyValue.DEC' (fn _ => let val  (TYPE as TYPE1) = TYPE1 ()
 val  (TYP_BIND as TYP_BIND1) = TYP_BIND1 ()
 in (spacer'(["\n\n", TYPE, TYP_BIND]))
end)
 in ( LrTable.NT 29, ( result, TYPE1left, TYP_BIND1right), rest671)

end
|  ( 97, ( ( _, ( MlyValue.DAT_BIND DAT_BIND1, _, DAT_BIND1right)) :: 
( _, ( MlyValue.DATATYPE DATATYPE1, DATATYPE1left, _)) :: rest671)) =>
 let val  result = MlyValue.DEC' (fn _ => let val  (DATATYPE as 
DATATYPE1) = DATATYPE1 ()
 val  (DAT_BIND as DAT_BIND1) = DAT_BIND1 ()
 in (spacer'(["\n\n", DATATYPE, DAT_BIND]))
end)
 in ( LrTable.NT 29, ( result, DATATYPE1left, DAT_BIND1right), rest671
)
end
|  ( 98, ( ( _, ( MlyValue.TYP_BIND TYP_BIND1, _, TYP_BIND1right)) :: 
( _, ( MlyValue.WITHTYPE WITHTYPE1, _, _)) :: ( _, ( MlyValue.DAT_BIND
 DAT_BIND1, _, _)) :: ( _, ( MlyValue.DATATYPE DATATYPE1, 
DATATYPE1left, _)) :: rest671)) => let val  result = MlyValue.DEC' (fn
 _ => let val  (DATATYPE as DATATYPE1) = DATATYPE1 ()
 val  (DAT_BIND as DAT_BIND1) = DAT_BIND1 ()
 val  (WITHTYPE as WITHTYPE1) = WITHTYPE1 ()
 val  (TYP_BIND as TYP_BIND1) = TYP_BIND1 ()
 in (spacer'(["\n\n", DATATYPE, DAT_BIND, WITHTYPE, TYP_BIND]))
end)
 in ( LrTable.NT 29, ( result, DATATYPE1left, TYP_BIND1right), rest671
)
end
|  ( 99, ( ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, _, 
LONG_TYP_CON1right)) :: ( _, ( MlyValue.DATATYPE DATATYPE2, _, _)) :: 
( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON 
TYP_CON1, _, _)) :: ( _, ( MlyValue.DATATYPE DATATYPE1, DATATYPE1left,
 _)) :: rest671)) => let val  result = MlyValue.DEC' (fn _ => let val 
 (DATATYPE as DATATYPE1) = DATATYPE1 ()
 val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  DATATYPE2 = DATATYPE2 ()
 val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 in (spacer'(["", DATATYPE, TYP_CON, EQUALOP, DATATYPE, LONG_TYP_CON])
)
end)
 in ( LrTable.NT 29, ( result, DATATYPE1left, LONG_TYP_CON1right), 
rest671)
end
|  ( 100, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.DEC DEC1, _, _)) :: ( _, ( MlyValue.WITH WITH1, _, _)) :: ( _
, ( MlyValue.DAT_BIND DAT_BIND1, _, _)) :: ( _, ( MlyValue.ABSTYPE 
ABSTYPE1, ABSTYPE1left, _)) :: rest671)) => let val  result = 
MlyValue.DEC' (fn _ => let val  (ABSTYPE as ABSTYPE1) = ABSTYPE1 ()
 val  (DAT_BIND as DAT_BIND1) = DAT_BIND1 ()
 val  (WITH as WITH1) = WITH1 ()
 val  (DEC as DEC1) = DEC1 ()
 val  (END as END1) = END1 ()
 in (spacer'(["", ABSTYPE, DAT_BIND, WITH, DEC, END]))
end)
 in ( LrTable.NT 29, ( result, ABSTYPE1left, END1right), rest671)
end
|  ( 101, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.DEC DEC1, _, _)) :: ( _, ( MlyValue.WITH WITH1, _, _)) :: ( _
, ( MlyValue.TYP_BIND TYP_BIND1, _, _)) :: ( _, ( MlyValue.WITHTYPE 
WITHTYPE1, _, _)) :: ( _, ( MlyValue.DAT_BIND DAT_BIND1, _, _)) :: ( _
, ( MlyValue.ABSTYPE ABSTYPE1, ABSTYPE1left, _)) :: rest671)) => let
 val  result = MlyValue.DEC' (fn _ => let val  (ABSTYPE as ABSTYPE1) =
 ABSTYPE1 ()
 val  (DAT_BIND as DAT_BIND1) = DAT_BIND1 ()
 val  (WITHTYPE as WITHTYPE1) = WITHTYPE1 ()
 val  (TYP_BIND as TYP_BIND1) = TYP_BIND1 ()
 val  (WITH as WITH1) = WITH1 ()
 val  (DEC as DEC1) = DEC1 ()
 val  (END as END1) = END1 ()
 in (
spacer'(["", ABSTYPE, DAT_BIND, WITHTYPE, TYP_BIND, WITH, DEC, END]))

end)
 in ( LrTable.NT 29, ( result, ABSTYPE1left, END1right), rest671)
end
|  ( 102, ( ( _, ( MlyValue.EX_BIND EX_BIND1, _, EX_BIND1right)) :: (
 _, ( MlyValue.EXCEPTION EXCEPTION1, EXCEPTION1left, _)) :: rest671))
 => let val  result = MlyValue.DEC' (fn _ => let val  (EXCEPTION as 
EXCEPTION1) = EXCEPTION1 ()
 val  (EX_BIND as EX_BIND1) = EX_BIND1 ()
 in (spacer'(["", EXCEPTION, EX_BIND]))
end)
 in ( LrTable.NT 29, ( result, EXCEPTION1left, EX_BIND1right), rest671
)
end
|  ( 103, ( ( _, ( MlyValue.LONG_STR_ID_LIST LONG_STR_ID_LIST1, _, 
LONG_STR_ID_LIST1right)) :: ( _, ( MlyValue.OPEN OPEN1, OPEN1left, _))
 :: rest671)) => let val  result = MlyValue.DEC' (fn _ => let val  (
OPEN as OPEN1) = OPEN1 ()
 val  (LONG_STR_ID_LIST as LONG_STR_ID_LIST1) = LONG_STR_ID_LIST1 ()
 in (spacer'(["", OPEN, LONG_STR_ID_LIST]))
end)
 in ( LrTable.NT 29, ( result, OPEN1left, LONG_STR_ID_LIST1right), 
rest671)
end
|  ( 104, ( ( _, ( MlyValue.VID_LIST VID_LIST1, _, VID_LIST1right)) ::
 ( _, ( MlyValue.INFIX INFIX1, INFIX1left, _)) :: rest671)) => let
 val  result = MlyValue.DEC' (fn _ => let val  (INFIX as INFIX1) = 
INFIX1 ()
 val  (VID_LIST as VID_LIST1) = VID_LIST1 ()
 in (spacer'(["", INFIX, VID_LIST]))
end)
 in ( LrTable.NT 29, ( result, INFIX1left, VID_LIST1right), rest671)

end
|  ( 105, ( ( _, ( MlyValue.VID_LIST VID_LIST1, _, VID_LIST1right)) ::
 ( _, ( MlyValue.INFIXR INFIXR1, INFIXR1left, _)) :: rest671)) => let
 val  result = MlyValue.DEC' (fn _ => let val  (INFIXR as INFIXR1) = 
INFIXR1 ()
 val  (VID_LIST as VID_LIST1) = VID_LIST1 ()
 in (spacer'(["", INFIXR, VID_LIST]))
end)
 in ( LrTable.NT 29, ( result, INFIXR1left, VID_LIST1right), rest671)

end
|  ( 106, ( ( _, ( MlyValue.VID_LIST VID_LIST1, _, VID_LIST1right)) ::
 ( _, ( MlyValue.INT INT1, _, _)) :: ( _, ( MlyValue.INFIX INFIX1, 
INFIX1left, _)) :: rest671)) => let val  result = MlyValue.DEC' (fn _
 => let val  (INFIX as INFIX1) = INFIX1 ()
 val  (INT as INT1) = INT1 ()
 val  (VID_LIST as VID_LIST1) = VID_LIST1 ()
 in (spacer'(["", INFIX, INT, VID_LIST]))
end)
 in ( LrTable.NT 29, ( result, INFIX1left, VID_LIST1right), rest671)

end
|  ( 107, ( ( _, ( MlyValue.VID_LIST VID_LIST1, _, VID_LIST1right)) ::
 ( _, ( MlyValue.INT INT1, _, _)) :: ( _, ( MlyValue.INFIXR INFIXR1, 
INFIXR1left, _)) :: rest671)) => let val  result = MlyValue.DEC' (fn _
 => let val  (INFIXR as INFIXR1) = INFIXR1 ()
 val  (INT as INT1) = INT1 ()
 val  (VID_LIST as VID_LIST1) = VID_LIST1 ()
 in (spacer'(["", INFIXR, INT, VID_LIST]))
end)
 in ( LrTable.NT 29, ( result, INFIXR1left, VID_LIST1right), rest671)

end
|  ( 108, ( ( _, ( MlyValue.VID_LIST VID_LIST1, _, VID_LIST1right)) ::
 ( _, ( MlyValue.NONFIX NONFIX1, NONFIX1left, _)) :: rest671)) => let
 val  result = MlyValue.DEC' (fn _ => let val  (NONFIX as NONFIX1) = 
NONFIX1 ()
 val  (VID_LIST as VID_LIST1) = VID_LIST1 ()
 in (spacer'(["", NONFIX, VID_LIST]))
end)
 in ( LrTable.NT 29, ( result, NONFIX1left, VID_LIST1right), rest671)

end
|  ( 109, ( rest671)) => let val  result = MlyValue.DEC (fn _ => (""))
 in ( LrTable.NT 30, ( result, defaultPos, defaultPos), rest671)
end
|  ( 110, ( ( _, ( MlyValue.DEC DEC1, _, DEC1right)) :: ( _, ( 
MlyValue.DEC' DEC'1, DEC'1left, _)) :: rest671)) => let val  result = 
MlyValue.DEC (fn _ => let val  (DEC' as DEC'1) = DEC'1 ()
 val  (DEC as DEC1) = DEC1 ()
 in ("" ^ DEC' ^ " " ^ DEC)
end)
 in ( LrTable.NT 30, ( result, DEC'1left, DEC1right), rest671)
end
|  ( 111, ( ( _, ( MlyValue.DEC DEC1, _, DEC1right)) :: ( _, ( 
MlyValue.SEMICOLON SEMICOLON1, SEMICOLON1left, _)) :: rest671)) => let
 val  result = MlyValue.DEC (fn _ => let val  (SEMICOLON as SEMICOLON1
) = SEMICOLON1 ()
 val  (DEC as DEC1) = DEC1 ()
 in (SEMICOLON ^ " " ^ DEC)
end)
 in ( LrTable.NT 30, ( result, SEMICOLON1left, DEC1right), rest671)

end
|  ( 112, ( ( _, ( MlyValue.DEC DEC3, _, DEC3right)) :: ( _, ( 
MlyValue.END END1, _, _)) :: ( _, ( MlyValue.DEC DEC2, _, _)) :: ( _, 
( MlyValue.IN IN1, _, _)) :: ( _, ( MlyValue.DEC DEC1, _, _)) :: ( _, 
( MlyValue.LOCAL LOCAL1, LOCAL1left, _)) :: rest671)) => let val  
result = MlyValue.DEC (fn _ => let val  (LOCAL as LOCAL1) = LOCAL1 ()
 val  DEC1 = DEC1 ()
 val  (IN as IN1) = IN1 ()
 val  DEC2 = DEC2 ()
 val  (END as END1) = END1 ()
 val  DEC3 = DEC3 ()
 in (spacer'([LOCAL, DEC1, IN, DEC2, END, DEC3]))
end)
 in ( LrTable.NT 30, ( result, LOCAL1left, DEC3right), rest671)
end
|  ( 113, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.PAT PAT1, 
PAT1left, _)) :: rest671)) => let val  result = MlyValue.VAL_BIND (fn
 _ => let val  (PAT as PAT1) = PAT1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (spacer'([PAT, EQUALOP, EXP]))
end)
 in ( LrTable.NT 31, ( result, PAT1left, EXP1right), rest671)
end
|  ( 114, ( ( _, ( MlyValue.VAL_BIND VAL_BIND1, _, VAL_BIND1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.EXP EXP1, _, _))
 :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.PAT 
PAT1, PAT1left, _)) :: rest671)) => let val  result = 
MlyValue.VAL_BIND (fn _ => let val  (PAT as PAT1) = PAT1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 val  (AND as AND1) = AND1 ()
 val  (VAL_BIND as VAL_BIND1) = VAL_BIND1 ()
 in (spacer'([PAT, EQUALOP, EXP, AND, VAL_BIND]))
end)
 in ( LrTable.NT 31, ( result, PAT1left, VAL_BIND1right), rest671)
end
|  ( 115, ( ( _, ( MlyValue.VAL_BIND VAL_BIND1, _, VAL_BIND1right)) ::
 ( _, ( MlyValue.REC REC1, REC1left, _)) :: rest671)) => let val  
result = MlyValue.VAL_BIND (fn _ => let val  (REC as REC1) = REC1 ()
 val  (VAL_BIND as VAL_BIND1) = VAL_BIND1 ()
 in (spacer'([REC, VAL_BIND]))
end)
 in ( LrTable.NT 31, ( result, REC1left, VAL_BIND1right), rest671)
end
|  ( 116, ( ( _, ( MlyValue.AT_PAT AT_PAT1, AT_PAT1left, AT_PAT1right)
) :: rest671)) => let val  result = MlyValue.AT_PAT_LIST (fn _ => let
 val  (AT_PAT as AT_PAT1) = AT_PAT1 ()
 in (AT_PAT)
end)
 in ( LrTable.NT 32, ( result, AT_PAT1left, AT_PAT1right), rest671)

end
|  ( 117, ( ( _, ( MlyValue.AT_PAT_LIST AT_PAT_LIST1, _, 
AT_PAT_LIST1right)) :: ( _, ( MlyValue.AT_PAT AT_PAT1, AT_PAT1left, _)
) :: rest671)) => let val  result = MlyValue.AT_PAT_LIST (fn _ => let
 val  (AT_PAT as AT_PAT1) = AT_PAT1 ()
 val  (AT_PAT_LIST as AT_PAT_LIST1) = AT_PAT_LIST1 ()
 in (AT_PAT ^ " " ^ AT_PAT_LIST)
end)
 in ( LrTable.NT 32, ( result, AT_PAT1left, AT_PAT_LIST1right), 
rest671)
end
|  ( 118, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.AT_PAT_LIST 
AT_PAT_LIST1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _)) :: 
rest671)) => let val  result = MlyValue.FVALBIND_BASE (fn _ => let
 val  (VID as VID1) = VID1 ()
 val  (AT_PAT_LIST as AT_PAT_LIST1) = AT_PAT_LIST1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (
case (peek (!Stack)) of
                         (s', EMPTY)                => spacer'([VID, AT_PAT_LIST, EQUALOP, EXP])

                       | (s', REQ (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          new_ref := number :: numlist;
                                                          spacer'([VID, AT_PAT_LIST, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
                                                        
                       | (s', ENS (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s';
                                                          new_ref := number :: numlist;
                                                          spacer'([VID, AT_PAT_LIST, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
                                                        
                                                        
                       | (s', BOTH (exp1, exp2))    => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s';
                                                          new_ref := number :: number :: numlist;
                                                          spacer'([VID, AT_PAT_LIST, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp1, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", "else if", "(", exp2, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
)
end)
 in ( LrTable.NT 33, ( result, VID1left, EXP1right), rest671)
end
|  ( 119, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP TYP1, _, _))
 :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( 
MlyValue.AT_PAT_LIST AT_PAT_LIST1, _, _)) :: ( _, ( MlyValue.VID VID1,
 VID1left, _)) :: rest671)) => let val  result = 
MlyValue.FVALBIND_BASE (fn _ => let val  (VID as VID1) = VID1 ()
 val  (AT_PAT_LIST as AT_PAT_LIST1) = AT_PAT_LIST1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (
case (peek (!Stack)) of
                         (s', EMPTY)                => (spacer'([VID, AT_PAT_LIST, COLON, TYP, EQUALOP, EXP]))


                       | (s', REQ (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          new_ref := number :: numlist;
                                                          spacer'([VID, AT_PAT_LIST, COLON, TYP, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
                                                        
                       | (s', ENS (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s';
                                                          new_ref := number :: numlist;
                                                          spacer'([VID, AT_PAT_LIST, COLON, TYP, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
                                                        
                                                        
                                                        
                       | (s', BOTH (exp1, exp2))    => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s';
                                                          new_ref := number :: number :: numlist;
                                                          spacer'([VID, AT_PAT_LIST, COLON, TYP, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp1, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", "else if", "(", exp2, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
)
end)
 in ( LrTable.NT 33, ( result, VID1left, EXP1right), rest671)
end
|  ( 120, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.AT_PAT_LIST 
AT_PAT_LIST1, _, _)) :: ( _, ( MlyValue.VID VID1, _, _)) :: ( _, ( 
MlyValue.OP OP1, OP1left, _)) :: rest671)) => let val  result = 
MlyValue.FVALBIND_BASE (fn _ => let val  (OP as OP1) = OP1 ()
 val  (VID as VID1) = VID1 ()
 val  (AT_PAT_LIST as AT_PAT_LIST1) = AT_PAT_LIST1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (
case (peek (!Stack)) of
                         (s', EMPTY)                => spacer'([OP, VID, AT_PAT_LIST, EQUALOP, EXP])

                       | (s', REQ (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s';
                                                          new_ref := number :: numlist;
                                                          spacer'([OP, VID, AT_PAT_LIST, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)

                       | (s', ENS (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          new_ref := number :: numlist;
                                                          spacer'([OP, VID, AT_PAT_LIST, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)

                       | (s', BOTH (exp1, exp2))    => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          spacer'([OP, VID, AT_PAT_LIST, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp1, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", "else if", "(", exp2, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
)
end)
 in ( LrTable.NT 33, ( result, OP1left, EXP1right), rest671)
end
|  ( 121, ( ( _, ( MlyValue.EXP EXP1, _, EXP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP TYP1, _, _))
 :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( 
MlyValue.AT_PAT_LIST AT_PAT_LIST1, _, _)) :: ( _, ( MlyValue.VID VID1,
 _, _)) :: ( _, ( MlyValue.OP OP1, OP1left, _)) :: rest671)) => let
 val  result = MlyValue.FVALBIND_BASE (fn _ => let val  (OP as OP1) = 
OP1 ()
 val  (VID as VID1) = VID1 ()
 val  (AT_PAT_LIST as AT_PAT_LIST1) = AT_PAT_LIST1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (EXP as EXP1) = EXP1 ()
 in (
case (peek (!Stack)) of
                         (s', EMPTY)                => spacer'([OP, VID, AT_PAT_LIST, COLON, TYP, EQUALOP, EXP])

                       | (s', REQ (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          spacer'([OP, VID, AT_PAT_LIST, COLON, TYP, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)

                       | (s', ENS (exp))            => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          spacer'([OP, VID, AT_PAT_LIST, COLON, TYP, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)

                       | (s', BOTH (exp1, exp2))    => (let
                                                          val number = !new_num
                                                          val numlist = !new_ref
                                                        in
                                                          Stack := s'; 
                                                          spacer'([OP, VID, AT_PAT_LIST, COLON, TYP, EQUALOP, "let", "val", "result", EQUALOP, EXP, "in", "if", "(", exp1, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Requires Failure in line", "$#$$#$", "\"", "else if", "(", exp2, ")", "=", "false", "then", 
                                                                 "raise Fail \" Function", VID, "Error:", "Ensures Failure in line", "%#%%#%", "\"", 
                                                                 "else", EXP, "end"])
                                                        end)
)
end)
 in ( LrTable.NT 33, ( result, OP1left, EXP1right), rest671)
end
|  ( 122, ( ( _, ( MlyValue.FVALBIND_BASE FVALBIND_BASE1, 
FVALBIND_BASE1left, FVALBIND_BASE1right)) :: rest671)) => let val  
result = MlyValue.FVAL_BIND (fn _ => let val  (FVALBIND_BASE as 
FVALBIND_BASE1) = FVALBIND_BASE1 ()
 in (
let
                               val (s', _) = pop (!Stack)
                             in 
                               Stack := s';
                               new_num := !new_num + 1;
                               spacer'([FVALBIND_BASE, ""])
                             end
)
end)
 in ( LrTable.NT 34, ( result, FVALBIND_BASE1left, FVALBIND_BASE1right
), rest671)
end
|  ( 123, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.BAR BAR1, _, _)) :: ( _, ( MlyValue.FVALBIND_BASE 
FVALBIND_BASE1, FVALBIND_BASE1left, _)) :: rest671)) => let val  
result = MlyValue.FVAL_BIND (fn _ => let val  (FVALBIND_BASE as 
FVALBIND_BASE1) = FVALBIND_BASE1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (spacer'([FVALBIND_BASE, " \n", BAR, FVAL_BIND]))
end)
 in ( LrTable.NT 34, ( result, FVALBIND_BASE1left, FVAL_BIND1right), 
rest671)
end
|  ( 124, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.FVALBIND_BASE 
FVALBIND_BASE1, FVALBIND_BASE1left, _)) :: rest671)) => let val  
result = MlyValue.FVAL_BIND (fn _ => let val  (FVALBIND_BASE as 
FVALBIND_BASE1) = FVALBIND_BASE1 ()
 val  (AND as AND1) = AND1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (
let
                                             val (s', _) = pop (!Stack)
                                           in 
                                             Stack := s';
                                             new_num := !new_num + 1;
                                             spacer'([FVALBIND_BASE, AND, FVAL_BIND])
                                           end
)
end)
 in ( LrTable.NT 34, ( result, FVALBIND_BASE1left, FVAL_BIND1right), 
rest671)
end
|  ( 125, ( ( _, ( MlyValue.FVAL_BIND FVAL_BIND1, _, FVAL_BIND1right))
 :: ( _, ( MlyValue.ASSERTIONS ASSERTIONS1, _, _)) :: ( _, ( 
MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.FVALBIND_BASE 
FVALBIND_BASE1, FVALBIND_BASE1left, _)) :: rest671)) => let val  
result = MlyValue.FVAL_BIND (fn _ => let val  (FVALBIND_BASE as 
FVALBIND_BASE1) = FVALBIND_BASE1 ()
 val  (AND as AND1) = AND1 ()
 val  ASSERTIONS1 = ASSERTIONS1 ()
 val  (FVAL_BIND as FVAL_BIND1) = FVAL_BIND1 ()
 in (
let
                                                       val (s', _) = pop (!Stack)
                                                     in 
                                                       Stack := s';
                                                       new_num := !new_num + 1;
                                                       spacer'([FVALBIND_BASE, "", AND, "", FVAL_BIND])
                                                     end
)
end)
 in ( LrTable.NT 34, ( result, FVALBIND_BASE1left, FVAL_BIND1right), 
rest671)
end
|  ( 126, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON TYP_CON1,
 TYP_CON1left, _)) :: rest671)) => let val  result = 
MlyValue.TYP_BIND' (fn _ => let val  (TYP_CON as TYP_CON1) = TYP_CON1
 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([TYP_CON, EQUALOP, TYP]))
end)
 in ( LrTable.NT 35, ( result, TYP_CON1left, TYP1right), rest671)
end
|  ( 127, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON TYP_CON1,
 _, _)) :: ( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, TYP_VAR_SEQ1left,
 _)) :: rest671)) => let val  result = MlyValue.TYP_BIND' (fn _ => let
 val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = TYP_VAR_SEQ1 ()
 val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([TYP_VAR_SEQ, TYP_CON, EQUALOP, TYP]))
end)
 in ( LrTable.NT 35, ( result, TYP_VAR_SEQ1left, TYP1right), rest671)

end
|  ( 128, ( ( _, ( MlyValue.TYP_BIND' TYP_BIND'1, TYP_BIND'1left, 
TYP_BIND'1right)) :: rest671)) => let val  result = MlyValue.TYP_BIND
 (fn _ => let val  (TYP_BIND' as TYP_BIND'1) = TYP_BIND'1 ()
 in (TYP_BIND')
end)
 in ( LrTable.NT 36, ( result, TYP_BIND'1left, TYP_BIND'1right), 
rest671)
end
|  ( 129, ( ( _, ( MlyValue.TYP_BIND TYP_BIND1, _, TYP_BIND1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.TYP_BIND' 
TYP_BIND'1, TYP_BIND'1left, _)) :: rest671)) => let val  result = 
MlyValue.TYP_BIND (fn _ => let val  (TYP_BIND' as TYP_BIND'1) = 
TYP_BIND'1 ()
 val  (AND as AND1) = AND1 ()
 val  (TYP_BIND as TYP_BIND1) = TYP_BIND1 ()
 in (spacer'([TYP_BIND', AND, TYP_BIND]))
end)
 in ( LrTable.NT 36, ( result, TYP_BIND'1left, TYP_BIND1right), 
rest671)
end
|  ( 130, ( ( _, ( MlyValue.CON_BIND CON_BIND1, _, CON_BIND1right)) ::
 ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON 
TYP_CON1, TYP_CON1left, _)) :: rest671)) => let val  result = 
MlyValue.DAT_BIND' (fn _ => let val  (TYP_CON as TYP_CON1) = TYP_CON1
 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (CON_BIND as CON_BIND1) = CON_BIND1 ()
 in (spacer'([TYP_CON, EQUALOP, CON_BIND]))
end)
 in ( LrTable.NT 37, ( result, TYP_CON1left, CON_BIND1right), rest671)

end
|  ( 131, ( ( _, ( MlyValue.CON_BIND CON_BIND1, _, CON_BIND1right)) ::
 ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON 
TYP_CON1, _, _)) :: ( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, 
TYP_VAR_SEQ1left, _)) :: rest671)) => let val  result = 
MlyValue.DAT_BIND' (fn _ => let val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = 
TYP_VAR_SEQ1 ()
 val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (CON_BIND as CON_BIND1) = CON_BIND1 ()
 in (spacer'([TYP_VAR_SEQ, TYP_CON, EQUALOP, CON_BIND]))
end)
 in ( LrTable.NT 37, ( result, TYP_VAR_SEQ1left, CON_BIND1right), 
rest671)
end
|  ( 132, ( ( _, ( MlyValue.DAT_BIND' DAT_BIND'1, DAT_BIND'1left, 
DAT_BIND'1right)) :: rest671)) => let val  result = MlyValue.DAT_BIND
 (fn _ => let val  (DAT_BIND' as DAT_BIND'1) = DAT_BIND'1 ()
 in (DAT_BIND')
end)
 in ( LrTable.NT 38, ( result, DAT_BIND'1left, DAT_BIND'1right), 
rest671)
end
|  ( 133, ( ( _, ( MlyValue.DAT_BIND DAT_BIND1, _, DAT_BIND1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.DAT_BIND' 
DAT_BIND'1, DAT_BIND'1left, _)) :: rest671)) => let val  result = 
MlyValue.DAT_BIND (fn _ => let val  (DAT_BIND' as DAT_BIND'1) = 
DAT_BIND'1 ()
 val  (AND as AND1) = AND1 ()
 val  (DAT_BIND as DAT_BIND1) = DAT_BIND1 ()
 in (spacer'([DAT_BIND', AND, DAT_BIND]))
end)
 in ( LrTable.NT 38, ( result, DAT_BIND'1left, DAT_BIND1right), 
rest671)
end
|  ( 134, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671
)) => let val  result = MlyValue.CONBIND_BASE (fn _ => let val  (VID
 as VID1) = VID1 ()
 in (VID)
end)
 in ( LrTable.NT 39, ( result, VID1left, VID1right), rest671)
end
|  ( 135, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _)) :: 
rest671)) => let val  result = MlyValue.CONBIND_BASE (fn _ => let val 
 (VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([VID, OF, TYP]))
end)
 in ( LrTable.NT 39, ( result, VID1left, TYP1right), rest671)
end
|  ( 136, ( ( _, ( MlyValue.VID VID1, _, VID1right)) :: ( _, ( 
MlyValue.OP OP1, OP1left, _)) :: rest671)) => let val  result = 
MlyValue.CONBIND_BASE (fn _ => let val  (OP as OP1) = OP1 ()
 val  (VID as VID1) = VID1 ()
 in (OP ^ " " ^ VID)
end)
 in ( LrTable.NT 39, ( result, OP1left, VID1right), rest671)
end
|  ( 137, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, _, _)) :: ( _, ( 
MlyValue.OP OP1, OP1left, _)) :: rest671)) => let val  result = 
MlyValue.CONBIND_BASE (fn _ => let val  (OP as OP1) = OP1 ()
 val  (VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([OP, VID, OF, TYP]))
end)
 in ( LrTable.NT 39, ( result, OP1left, TYP1right), rest671)
end
|  ( 138, ( ( _, ( MlyValue.CONBIND_BASE CONBIND_BASE1, 
CONBIND_BASE1left, CONBIND_BASE1right)) :: rest671)) => let val  
result = MlyValue.CON_BIND (fn _ => let val  (CONBIND_BASE as 
CONBIND_BASE1) = CONBIND_BASE1 ()
 in (CONBIND_BASE)
end)
 in ( LrTable.NT 40, ( result, CONBIND_BASE1left, CONBIND_BASE1right),
 rest671)
end
|  ( 139, ( ( _, ( MlyValue.CON_BIND CON_BIND1, _, CON_BIND1right)) ::
 ( _, ( MlyValue.BAR BAR1, _, _)) :: ( _, ( MlyValue.CONBIND_BASE 
CONBIND_BASE1, CONBIND_BASE1left, _)) :: rest671)) => let val  result
 = MlyValue.CON_BIND (fn _ => let val  (CONBIND_BASE as CONBIND_BASE1)
 = CONBIND_BASE1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (CON_BIND as CON_BIND1) = CON_BIND1 ()
 in (spacer'([CONBIND_BASE, BAR, CON_BIND]))
end)
 in ( LrTable.NT 40, ( result, CONBIND_BASE1left, CON_BIND1right), 
rest671)
end
|  ( 140, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671
)) => let val  result = MlyValue.EX_BIND_BASE (fn _ => let val  (VID
 as VID1) = VID1 ()
 in (VID)
end)
 in ( LrTable.NT 41, ( result, VID1left, VID1right), rest671)
end
|  ( 141, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _)) :: 
rest671)) => let val  result = MlyValue.EX_BIND_BASE (fn _ => let val 
 (VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([VID, OF, TYP]))
end)
 in ( LrTable.NT 41, ( result, VID1left, TYP1right), rest671)
end
|  ( 142, ( ( _, ( MlyValue.VID VID1, _, VID1right)) :: ( _, ( 
MlyValue.OP OP1, OP1left, _)) :: rest671)) => let val  result = 
MlyValue.EX_BIND_BASE (fn _ => let val  (OP as OP1) = OP1 ()
 val  (VID as VID1) = VID1 ()
 in (OP ^ " " ^ VID)
end)
 in ( LrTable.NT 41, ( result, OP1left, VID1right), rest671)
end
|  ( 143, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, _, _)) :: ( _, ( 
MlyValue.OP OP1, OP1left, _)) :: rest671)) => let val  result = 
MlyValue.EX_BIND_BASE (fn _ => let val  OP1 = OP1 ()
 val  (VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([VID, OF, TYP]))
end)
 in ( LrTable.NT 41, ( result, OP1left, TYP1right), rest671)
end
|  ( 144, ( ( _, ( MlyValue.LONG_VID LONG_VID1, _, LONG_VID1right)) ::
 ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.VID VID1,
 VID1left, _)) :: rest671)) => let val  result = MlyValue.EX_BIND_BASE
 (fn _ => let val  (VID as VID1) = VID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (spacer'([VID, EQUALOP, LONG_VID]))
end)
 in ( LrTable.NT 41, ( result, VID1left, LONG_VID1right), rest671)
end
|  ( 145, ( ( _, ( MlyValue.LONG_VID LONG_VID1, _, LONG_VID1right)) ::
 ( _, ( MlyValue.OP OP1, _, _)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _
, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _)) :: rest671)) => let
 val  result = MlyValue.EX_BIND_BASE (fn _ => let val  (VID as VID1) =
 VID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (OP as OP1) = OP1 ()
 val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (spacer'([VID, EQUALOP, OP, LONG_VID]))
end)
 in ( LrTable.NT 41, ( result, VID1left, LONG_VID1right), rest671)
end
|  ( 146, ( ( _, ( MlyValue.LONG_VID LONG_VID1, _, LONG_VID1right)) ::
 ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.VID VID1,
 _, _)) :: ( _, ( MlyValue.OP OP1, OP1left, _)) :: rest671)) => let
 val  result = MlyValue.EX_BIND_BASE (fn _ => let val  (OP as OP1) = 
OP1 ()
 val  (VID as VID1) = VID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (spacer'([OP, VID, EQUALOP, LONG_VID]))
end)
 in ( LrTable.NT 41, ( result, OP1left, LONG_VID1right), rest671)
end
|  ( 147, ( ( _, ( MlyValue.LONG_VID LONG_VID1, _, LONG_VID1right)) ::
 ( _, ( MlyValue.OP OP2, _, _)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _
, _)) :: ( _, ( MlyValue.VID VID1, _, _)) :: ( _, ( MlyValue.OP OP1, 
OP1left, _)) :: rest671)) => let val  result = MlyValue.EX_BIND_BASE
 (fn _ => let val  (OP as OP1) = OP1 ()
 val  (VID as VID1) = VID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  OP2 = OP2 ()
 val  (LONG_VID as LONG_VID1) = LONG_VID1 ()
 in (spacer'([OP, VID, EQUALOP, OP, LONG_VID]))
end)
 in ( LrTable.NT 41, ( result, OP1left, LONG_VID1right), rest671)
end
|  ( 148, ( ( _, ( MlyValue.EX_BIND_BASE EX_BIND_BASE1, 
EX_BIND_BASE1left, EX_BIND_BASE1right)) :: rest671)) => let val  
result = MlyValue.EX_BIND (fn _ => let val  (EX_BIND_BASE as 
EX_BIND_BASE1) = EX_BIND_BASE1 ()
 in (EX_BIND_BASE)
end)
 in ( LrTable.NT 42, ( result, EX_BIND_BASE1left, EX_BIND_BASE1right),
 rest671)
end
|  ( 149, ( ( _, ( MlyValue.EX_BIND EX_BIND1, _, EX_BIND1right)) :: (
 _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.EX_BIND_BASE 
EX_BIND_BASE1, EX_BIND_BASE1left, _)) :: rest671)) => let val  result
 = MlyValue.EX_BIND (fn _ => let val  (EX_BIND_BASE as EX_BIND_BASE1)
 = EX_BIND_BASE1 ()
 val  (AND as AND1) = AND1 ()
 val  (EX_BIND as EX_BIND1) = EX_BIND1 ()
 in (spacer'([EX_BIND_BASE, AND, EX_BIND]))
end)
 in ( LrTable.NT 42, ( result, EX_BIND_BASE1left, EX_BIND1right), 
rest671)
end
|  ( 150, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.SELECTOR (fn _ => let val  (ID as ID1)
 = ID1 ()
 in (ID)
end)
 in ( LrTable.NT 85, ( result, ID1left, ID1right), rest671)
end
|  ( 151, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671
)) => let val  result = MlyValue.SELECTOR (fn _ => let val  (INT as 
INT1) = INT1 ()
 in (INT)
end)
 in ( LrTable.NT 85, ( result, INT1left, INT1right), rest671)
end
|  ( 152, ( ( _, ( MlyValue.TYP' TYP'2, _, TYP'2right)) :: ( _, ( 
MlyValue.TIMES TIMES1, _, _)) :: ( _, ( MlyValue.TYP' TYP'1, TYP'1left
, _)) :: rest671)) => let val  result = MlyValue.TYP_TUPLE (fn _ =>
 let val  TYP'1 = TYP'1 ()
 val  (TIMES as TIMES1) = TIMES1 ()
 val  TYP'2 = TYP'2 ()
 in (spacer'([TYP'1, TIMES, TYP'2]))
end)
 in ( LrTable.NT 43, ( result, TYP'1left, TYP'2right), rest671)
end
|  ( 153, ( ( _, ( MlyValue.TYP_TUPLE TYP_TUPLE1, _, TYP_TUPLE1right))
 :: ( _, ( MlyValue.TIMES TIMES1, _, _)) :: ( _, ( MlyValue.TYP' TYP'1
, TYP'1left, _)) :: rest671)) => let val  result = MlyValue.TYP_TUPLE
 (fn _ => let val  (TYP' as TYP'1) = TYP'1 ()
 val  (TIMES as TIMES1) = TIMES1 ()
 val  (TYP_TUPLE as TYP_TUPLE1) = TYP_TUPLE1 ()
 in (spacer'([TYP', TIMES, TYP_TUPLE]))
end)
 in ( LrTable.NT 43, ( result, TYP'1left, TYP_TUPLE1right), rest671)

end
|  ( 154, ( ( _, ( MlyValue.TY_CON TY_CON1, _, TY_CON1right)) :: ( _, 
( MlyValue.DOT DOT1, _, _)) :: ( _, ( MlyValue.ALL_IDs ALL_IDs1, 
ALL_IDs1left, _)) :: rest671)) => let val  result = MlyValue.TY_CON
 (fn _ => let val  (ALL_IDs as ALL_IDs1) = ALL_IDs1 ()
 val  (DOT as DOT1) = DOT1 ()
 val  (TY_CON as TY_CON1) = TY_CON1 ()
 in (spacer([ALL_IDs, DOT, TY_CON]))
end)
 in ( LrTable.NT 95, ( result, ALL_IDs1left, TY_CON1right), rest671)

end
|  ( 155, ( ( _, ( MlyValue.ALL_IDs ALL_IDs1, ALL_IDs1left, 
ALL_IDs1right)) :: rest671)) => let val  result = MlyValue.TY_CON (fn
 _ => let val  (ALL_IDs as ALL_IDs1) = ALL_IDs1 ()
 in (ALL_IDs)
end)
 in ( LrTable.NT 95, ( result, ALL_IDs1left, ALL_IDs1right), rest671)

end
|  ( 156, ( ( _, ( MlyValue.TYP TYP2, _, TYP2right)) :: ( _, ( 
MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.TYP TYP1, TYP1left, _
)) :: rest671)) => let val  result = MlyValue.TYP_SEQ (fn _ => let
 val  TYP1 = TYP1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  TYP2 = TYP2 ()
 in (TYP1 ^ " " ^ COMMA ^ " " ^ TYP2)
end)
 in ( LrTable.NT 44, ( result, TYP1left, TYP2right), rest671)
end
|  ( 157, ( ( _, ( MlyValue.TYP_SEQ TYP_SEQ1, _, TYP_SEQ1right)) :: (
 _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.TYP TYP1, 
TYP1left, _)) :: rest671)) => let val  result = MlyValue.TYP_SEQ (fn _
 => let val  (TYP as TYP1) = TYP1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (TYP_SEQ as TYP_SEQ1) = TYP_SEQ1 ()
 in (TYP ^ " " ^ COMMA ^ " " ^ TYP_SEQ)
end)
 in ( LrTable.NT 44, ( result, TYP1left, TYP_SEQ1right), rest671)
end
|  ( 158, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.SELECTOR SELECTOR1, 
SELECTOR1left, _)) :: rest671)) => let val  result = MlyValue.TLABEL
 (fn _ => let val  (SELECTOR as SELECTOR1) = SELECTOR1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([SELECTOR, COLON, TYP]))
end)
 in ( LrTable.NT 86, ( result, SELECTOR1left, TYP1right), rest671)
end
|  ( 159, ( ( _, ( MlyValue.TLABELS TLABELS1, _, TLABELS1right)) :: (
 _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.TLABEL TLABEL1,
 TLABEL1left, _)) :: rest671)) => let val  result = MlyValue.TLABELS
 (fn _ => let val  (TLABEL as TLABEL1) = TLABEL1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (TLABELS as TLABELS1) = TLABELS1 ()
 in (spacer'([TLABEL, COMMA, TLABELS]))
end)
 in ( LrTable.NT 87, ( result, TLABEL1left, TLABELS1right), rest671)

end
|  ( 160, ( ( _, ( MlyValue.TLABEL TLABEL1, TLABEL1left, TLABEL1right)
) :: rest671)) => let val  result = MlyValue.TLABELS (fn _ => let val 
 (TLABEL as TLABEL1) = TLABEL1 ()
 in (TLABEL)
end)
 in ( LrTable.NT 87, ( result, TLABEL1left, TLABEL1right), rest671)

end
|  ( 161, ( ( _, ( MlyValue.TYP_VAR TYP_VAR1, TYP_VAR1left, 
TYP_VAR1right)) :: rest671)) => let val  result = MlyValue.TYP' (fn _
 => let val  (TYP_VAR as TYP_VAR1) = TYP_VAR1 ()
 in (TYP_VAR)
end)
 in ( LrTable.NT 88, ( result, TYP_VAR1left, TYP_VAR1right), rest671)

end
|  ( 162, ( ( _, ( MlyValue.RCURLY RCURLY1, _, RCURLY1right)) :: ( _, 
( MlyValue.TLABELS TLABELS1, _, _)) :: ( _, ( MlyValue.LCURLY LCURLY1,
 LCURLY1left, _)) :: rest671)) => let val  result = MlyValue.TYP' (fn
 _ => let val  (LCURLY as LCURLY1) = LCURLY1 ()
 val  (TLABELS as TLABELS1) = TLABELS1 ()
 val  (RCURLY as RCURLY1) = RCURLY1 ()
 in (spacer'([LCURLY, TLABELS, RCURLY]))
end)
 in ( LrTable.NT 88, ( result, LCURLY1left, RCURLY1right), rest671)

end
|  ( 163, ( ( _, ( MlyValue.RCURLY RCURLY1, _, RCURLY1right)) :: ( _, 
( MlyValue.LCURLY LCURLY1, LCURLY1left, _)) :: rest671)) => let val  
result = MlyValue.TYP' (fn _ => let val  (LCURLY as LCURLY1) = LCURLY1
 ()
 val  (RCURLY as RCURLY1) = RCURLY1 ()
 in (LCURLY ^ " " ^ RCURLY)
end)
 in ( LrTable.NT 88, ( result, LCURLY1left, RCURLY1right), rest671)

end
|  ( 164, ( ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, _, 
LONG_TYP_CON1right)) :: ( _, ( MlyValue.RPAREN RPAREN1, _, _)) :: ( _,
 ( MlyValue.TYP_SEQ TYP_SEQ1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1
, LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.TYP' (fn
 _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (TYP_SEQ as TYP_SEQ1) = TYP_SEQ1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 in (spacer'([LPAREN, TYP_SEQ, RPAREN, LONG_TYP_CON]))
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, LONG_TYP_CON1right), 
rest671)
end
|  ( 165, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.TYP TYP1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.TYP' (fn _
 => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, TYP, RPAREN]))
end)
 in ( LrTable.NT 88, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 166, ( ( _, ( MlyValue.TY_CON TY_CON1, _, TY_CON1right)) :: ( _, 
( MlyValue.TYP' TYP'1, TYP'1left, _)) :: rest671)) => let val  result
 = MlyValue.TYP' (fn _ => let val  (TYP' as TYP'1) = TYP'1 ()
 val  (TY_CON as TY_CON1) = TY_CON1 ()
 in (TYP' ^ " " ^ TY_CON)
end)
 in ( LrTable.NT 88, ( result, TYP'1left, TY_CON1right), rest671)
end
|  ( 167, ( ( _, ( MlyValue.TY_CON TY_CON1, TY_CON1left, TY_CON1right)
) :: rest671)) => let val  result = MlyValue.TYP' (fn _ => let val  (
TY_CON as TY_CON1) = TY_CON1 ()
 in (TY_CON)
end)
 in ( LrTable.NT 88, ( result, TY_CON1left, TY_CON1right), rest671)

end
|  ( 168, ( ( _, ( MlyValue.TYP_TUPLE TYP_TUPLE1, TYP_TUPLE1left, 
TYP_TUPLE1right)) :: rest671)) => let val  result = MlyValue.TYP (fn _
 => let val  (TYP_TUPLE as TYP_TUPLE1) = TYP_TUPLE1 ()
 in (TYP_TUPLE)
end)
 in ( LrTable.NT 45, ( result, TYP_TUPLE1left, TYP_TUPLE1right), 
rest671)
end
|  ( 169, ( ( _, ( MlyValue.TYP TYP2, _, TYP2right)) :: ( _, ( 
MlyValue.ARROW ARROW1, _, _)) :: ( _, ( MlyValue.TYP TYP1, TYP1left, _
)) :: rest671)) => let val  result = MlyValue.TYP (fn _ => let val  
TYP1 = TYP1 ()
 val  (ARROW as ARROW1) = ARROW1 ()
 val  TYP2 = TYP2 ()
 in (spacer'([TYP1, ARROW, TYP2]))
end)
 in ( LrTable.NT 45, ( result, TYP1left, TYP2right), rest671)
end
|  ( 170, ( ( _, ( MlyValue.TYP' TYP'1, TYP'1left, TYP'1right)) :: 
rest671)) => let val  result = MlyValue.TYP (fn _ => let val  (TYP'
 as TYP'1) = TYP'1 ()
 in (TYP')
end)
 in ( LrTable.NT 45, ( result, TYP'1left, TYP'1right), rest671)
end
|  ( 171, ( ( _, ( MlyValue.PAT PAT1, PAT1left, PAT1right)) :: rest671
)) => let val  result = MlyValue.PAT_LIST (fn _ => let val  (PAT as 
PAT1) = PAT1 ()
 in (PAT)
end)
 in ( LrTable.NT 47, ( result, PAT1left, PAT1right), rest671)
end
|  ( 172, ( ( _, ( MlyValue.PAT_LIST PAT_LIST1, _, PAT_LIST1right)) ::
 ( _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.PAT PAT1, 
PAT1left, _)) :: rest671)) => let val  result = MlyValue.PAT_LIST (fn
 _ => let val  (PAT as PAT1) = PAT1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (PAT_LIST as PAT_LIST1) = PAT_LIST1 ()
 in (PAT ^ " " ^ COMMA ^ " " ^ PAT_LIST)
end)
 in ( LrTable.NT 47, ( result, PAT1left, PAT_LIST1right), rest671)
end
|  ( 173, ( ( _, ( MlyValue.PAT PAT1, PAT1left, PAT1right)) :: rest671
)) => let val  result = MlyValue.OR_PAT_LIST (fn _ => let val  (PAT
 as PAT1) = PAT1 ()
 in (PAT)
end)
 in ( LrTable.NT 93, ( result, PAT1left, PAT1right), rest671)
end
|  ( 174, ( ( _, ( MlyValue.OR_PAT_LIST OR_PAT_LIST1, _, 
OR_PAT_LIST1right)) :: ( _, ( MlyValue.BAR BAR1, _, _)) :: ( _, ( 
MlyValue.PAT PAT1, PAT1left, _)) :: rest671)) => let val  result = 
MlyValue.OR_PAT_LIST (fn _ => let val  (PAT as PAT1) = PAT1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (OR_PAT_LIST as OR_PAT_LIST1) = OR_PAT_LIST1 ()
 in (spacer'([PAT, BAR, OR_PAT_LIST]))
end)
 in ( LrTable.NT 93, ( result, PAT1left, OR_PAT_LIST1right), rest671)

end
|  ( 175, ( ( _, ( MlyValue.PAT PAT2, _, PAT2right)) :: ( _, ( 
MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.PAT PAT1, PAT1left, _
)) :: rest671)) => let val  result = MlyValue.PAT_TUPLE (fn _ => let
 val  PAT1 = PAT1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  PAT2 = PAT2 ()
 in (PAT1 ^ " " ^ COMMA ^ " " ^ PAT2)
end)
 in ( LrTable.NT 48, ( result, PAT1left, PAT2right), rest671)
end
|  ( 176, ( ( _, ( MlyValue.PAT_TUPLE PAT_TUPLE1, _, PAT_TUPLE1right))
 :: ( _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.PAT PAT1, 
PAT1left, _)) :: rest671)) => let val  result = MlyValue.PAT_TUPLE (fn
 _ => let val  (PAT as PAT1) = PAT1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (PAT_TUPLE as PAT_TUPLE1) = PAT_TUPLE1 ()
 in (PAT ^ " " ^ COMMA ^ " " ^ PAT_TUPLE)
end)
 in ( LrTable.NT 48, ( result, PAT1left, PAT_TUPLE1right), rest671)

end
|  ( 177, ( ( _, ( MlyValue.PAT PAT2, _, PAT2right)) :: ( _, ( 
MlyValue.AS AS1, _, _)) :: ( _, ( MlyValue.PAT PAT1, PAT1left, _)) :: 
rest671)) => let val  result = MlyValue.PAT (fn _ => let val  PAT1 = 
PAT1 ()
 val  (AS as AS1) = AS1 ()
 val  PAT2 = PAT2 ()
 in (spacer'([PAT1, AS, PAT2]))
end)
 in ( LrTable.NT 51, ( result, PAT1left, PAT2right), rest671)
end
|  ( 178, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.PAT PAT1, PAT1left, _
)) :: rest671)) => let val  result = MlyValue.PAT (fn _ => let val  (
PAT as PAT1) = PAT1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([PAT, COLON, TYP]))
end)
 in ( LrTable.NT 51, ( result, PAT1left, TYP1right), rest671)
end
|  ( 179, ( ( _, ( MlyValue.AT_PAT_LIST AT_PAT_LIST1, AT_PAT_LIST1left
, AT_PAT_LIST1right)) :: rest671)) => let val  result = MlyValue.PAT
 (fn _ => let val  (AT_PAT_LIST as AT_PAT_LIST1) = AT_PAT_LIST1 ()
 in (AT_PAT_LIST)
end)
 in ( LrTable.NT 51, ( result, AT_PAT_LIST1left, AT_PAT_LIST1right), 
rest671)
end
|  ( 180, ( ( _, ( MlyValue.AT_PAT' AT_PAT'1, AT_PAT'1left, 
AT_PAT'1right)) :: rest671)) => let val  result = MlyValue.AT_PAT (fn
 _ => let val  (AT_PAT' as AT_PAT'1) = AT_PAT'1 ()
 in (AT_PAT')
end)
 in ( LrTable.NT 49, ( result, AT_PAT'1left, AT_PAT'1right), rest671)

end
|  ( 181, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.PAT PAT1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, 
LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.AT_PAT (fn
 _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (PAT as PAT1) = PAT1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, PAT, RPAREN]))
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 182, ( ( _, ( MlyValue.ID_NO_EQ ID_NO_EQ1, ID_NO_EQ1left, 
ID_NO_EQ1right)) :: rest671)) => let val  result = MlyValue.AT_PAT (fn
 _ => let val  (ID_NO_EQ as ID_NO_EQ1) = ID_NO_EQ1 ()
 in (ID_NO_EQ)
end)
 in ( LrTable.NT 49, ( result, ID_NO_EQ1left, ID_NO_EQ1right), rest671
)
end
|  ( 183, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.LPAREN LPAREN1, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.AT_PAT (fn _ => let val  LPAREN1 = LPAREN1 ()
 val  RPAREN1 = RPAREN1 ()
 in ("()")
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 184, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.PAT_LIST PAT_LIST1, _, _)) :: ( _, ( MlyValue.COMMA COMMA1,
 _, _)) :: ( _, ( MlyValue.PAT PAT1, _, _)) :: ( _, ( MlyValue.LPAREN 
LPAREN1, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.AT_PAT (fn _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (PAT as PAT1) = PAT1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (PAT_LIST as PAT_LIST1) = PAT_LIST1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, PAT, COMMA, PAT_LIST, RPAREN]))
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 185, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.OR_PAT_LIST OR_PAT_LIST1, _, _)) :: ( _, ( MlyValue.BAR 
BAR1, _, _)) :: ( _, ( MlyValue.PAT PAT1, _, _)) :: ( _, ( 
MlyValue.LPAREN LPAREN1, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.AT_PAT (fn _ => let val  (LPAREN as LPAREN1) = 
LPAREN1 ()
 val  (PAT as PAT1) = PAT1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (OR_PAT_LIST as OR_PAT_LIST1) = OR_PAT_LIST1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, PAT, BAR, OR_PAT_LIST, RPAREN]))
end)
 in ( LrTable.NT 49, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 186, ( ( _, ( MlyValue.LONG_ID_NO_EQ LONG_ID_NO_EQ1, _, 
LONG_ID_NO_EQ1right)) :: ( _, ( MlyValue.OP OP1, OP1left, _)) :: 
rest671)) => let val  result = MlyValue.AT_PAT' (fn _ => let val  (OP
 as OP1) = OP1 ()
 val  (LONG_ID_NO_EQ as LONG_ID_NO_EQ1) = LONG_ID_NO_EQ1 ()
 in (spacer'([OP, LONG_ID_NO_EQ]))
end)
 in ( LrTable.NT 92, ( result, OP1left, LONG_ID_NO_EQ1right), rest671)

end
|  ( 187, ( ( _, ( MlyValue.LONG_ID_NO_EQ LONG_ID_NO_EQ1, 
LONG_ID_NO_EQ1left, LONG_ID_NO_EQ1right)) :: rest671)) => let val  
result = MlyValue.AT_PAT' (fn _ => let val  (LONG_ID_NO_EQ as 
LONG_ID_NO_EQ1) = LONG_ID_NO_EQ1 ()
 in (LONG_ID_NO_EQ)
end)
 in ( LrTable.NT 92, ( result, LONG_ID_NO_EQ1left, LONG_ID_NO_EQ1right
), rest671)
end
|  ( 188, ( ( _, ( MlyValue.CON CON1, CON1left, CON1right)) :: rest671
)) => let val  result = MlyValue.AT_PAT' (fn _ => let val  (CON as 
CON1) = CON1 ()
 in (CON)
end)
 in ( LrTable.NT 92, ( result, CON1left, CON1right), rest671)
end
|  ( 189, ( ( _, ( MlyValue.WILD WILD1, WILD1left, WILD1right)) :: 
rest671)) => let val  result = MlyValue.AT_PAT' (fn _ => let val  (
WILD as WILD1) = WILD1 ()
 in (WILD)
end)
 in ( LrTable.NT 92, ( result, WILD1left, WILD1right), rest671)
end
|  ( 190, ( ( _, ( MlyValue.RBRACK RBRACK1, _, RBRACK1right)) :: ( _, 
( MlyValue.LBRACK LBRACK1, LBRACK1left, _)) :: rest671)) => let val  
result = MlyValue.AT_PAT' (fn _ => let val  (LBRACK as LBRACK1) = 
LBRACK1 ()
 val  (RBRACK as RBRACK1) = RBRACK1 ()
 in (LBRACK ^ " " ^ RBRACK)
end)
 in ( LrTable.NT 92, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 191, ( ( _, ( MlyValue.RBRACK RBRACK1, _, RBRACK1right)) :: ( _, 
( MlyValue.PAT_LIST PAT_LIST1, _, _)) :: ( _, ( MlyValue.LBRACK 
LBRACK1, LBRACK1left, _)) :: rest671)) => let val  result = 
MlyValue.AT_PAT' (fn _ => let val  (LBRACK as LBRACK1) = LBRACK1 ()
 val  (PAT_LIST as PAT_LIST1) = PAT_LIST1 ()
 val  (RBRACK as RBRACK1) = RBRACK1 ()
 in (spacer'([LBRACK, PAT_LIST, RBRACK]))
end)
 in ( LrTable.NT 92, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 192, ( ( _, ( MlyValue.RBRACK RBRACK1, _, RBRACK1right)) :: ( _, 
( MlyValue.LBRACK LBRACK1, _, _)) :: ( _, ( MlyValue.HASH HASH1, 
HASH1left, _)) :: rest671)) => let val  result = MlyValue.AT_PAT' (fn
 _ => let val  (HASH as HASH1) = HASH1 ()
 val  (LBRACK as LBRACK1) = LBRACK1 ()
 val  (RBRACK as RBRACK1) = RBRACK1 ()
 in (spacer'([HASH, LBRACK, RBRACK]))
end)
 in ( LrTable.NT 92, ( result, HASH1left, RBRACK1right), rest671)
end
|  ( 193, ( ( _, ( MlyValue.RBRACK RBRACK1, _, RBRACK1right)) :: ( _, 
( MlyValue.PAT_LIST PAT_LIST1, _, _)) :: ( _, ( MlyValue.LBRACK 
LBRACK1, _, _)) :: ( _, ( MlyValue.HASH HASH1, HASH1left, _)) :: 
rest671)) => let val  result = MlyValue.AT_PAT' (fn _ => let val  (
HASH as HASH1) = HASH1 ()
 val  (LBRACK as LBRACK1) = LBRACK1 ()
 val  (PAT_LIST as PAT_LIST1) = PAT_LIST1 ()
 val  (RBRACK as RBRACK1) = RBRACK1 ()
 in (spacer'([HASH, LBRACK, PAT_LIST, RBRACK]))
end)
 in ( LrTable.NT 92, ( result, HASH1left, RBRACK1right), rest671)
end
|  ( 194, ( ( _, ( MlyValue.RCURLY RCURLY1, _, RCURLY1right)) :: ( _, 
( MlyValue.LCURLY LCURLY1, LCURLY1left, _)) :: rest671)) => let val  
result = MlyValue.AT_PAT' (fn _ => let val  (LCURLY as LCURLY1) = 
LCURLY1 ()
 val  (RCURLY as RCURLY1) = RCURLY1 ()
 in (LCURLY ^ " " ^ RCURLY)
end)
 in ( LrTable.NT 92, ( result, LCURLY1left, RCURLY1right), rest671)

end
|  ( 195, ( ( _, ( MlyValue.RCURLY RCURLY1, _, RCURLY1right)) :: ( _, 
( MlyValue.PLABELS PLABELS1, _, _)) :: ( _, ( MlyValue.LCURLY LCURLY1,
 LCURLY1left, _)) :: rest671)) => let val  result = MlyValue.AT_PAT'
 (fn _ => let val  (LCURLY as LCURLY1) = LCURLY1 ()
 val  (PLABELS as PLABELS1) = PLABELS1 ()
 val  (RCURLY as RCURLY1) = RCURLY1 ()
 in (spacer'([LCURLY, PLABELS, RCURLY]))
end)
 in ( LrTable.NT 92, ( result, LCURLY1left, RCURLY1right), rest671)

end
|  ( 196, ( ( _, ( MlyValue.PAT PAT1, _, PAT1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SELECTOR 
SELECTOR1, SELECTOR1left, _)) :: rest671)) => let val  result = 
MlyValue.PLABEL (fn _ => let val  (SELECTOR as SELECTOR1) = SELECTOR1
 ()
 val  EQUALOP1 = EQUALOP1 ()
 val  (PAT as PAT1) = PAT1 ()
 in (spacer'([SELECTOR, "=", PAT]))
end)
 in ( LrTable.NT 90, ( result, SELECTOR1left, PAT1right), rest671)
end
|  ( 197, ( ( _, ( MlyValue.ID_NO_EQ ID_NO_EQ1, ID_NO_EQ1left, 
ID_NO_EQ1right)) :: rest671)) => let val  result = MlyValue.PLABEL (fn
 _ => let val  (ID_NO_EQ as ID_NO_EQ1) = ID_NO_EQ1 ()
 in (ID_NO_EQ)
end)
 in ( LrTable.NT 90, ( result, ID_NO_EQ1left, ID_NO_EQ1right), rest671
)
end
|  ( 198, ( ( _, ( MlyValue.PAT PAT1, _, PAT1right)) :: ( _, ( 
MlyValue.AS AS1, _, _)) :: ( _, ( MlyValue.ID_NO_EQ ID_NO_EQ1, 
ID_NO_EQ1left, _)) :: rest671)) => let val  result = MlyValue.PLABEL
 (fn _ => let val  (ID_NO_EQ as ID_NO_EQ1) = ID_NO_EQ1 ()
 val  (AS as AS1) = AS1 ()
 val  (PAT as PAT1) = PAT1 ()
 in (spacer'([ID_NO_EQ, AS, PAT]))
end)
 in ( LrTable.NT 90, ( result, ID_NO_EQ1left, PAT1right), rest671)
end
|  ( 199, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.ID_NO_EQ ID_NO_EQ1, 
ID_NO_EQ1left, _)) :: rest671)) => let val  result = MlyValue.PLABEL
 (fn _ => let val  (ID_NO_EQ as ID_NO_EQ1) = ID_NO_EQ1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([ID_NO_EQ, COLON, TYP]))
end)
 in ( LrTable.NT 90, ( result, ID_NO_EQ1left, TYP1right), rest671)
end
|  ( 200, ( ( _, ( MlyValue.PAT PAT1, _, PAT1right)) :: ( _, ( 
MlyValue.AS AS1, _, _)) :: ( _, ( MlyValue.TYP TYP1, _, _)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.ID_NO_EQ ID_NO_EQ1, 
ID_NO_EQ1left, _)) :: rest671)) => let val  result = MlyValue.PLABEL
 (fn _ => let val  (ID_NO_EQ as ID_NO_EQ1) = ID_NO_EQ1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (AS as AS1) = AS1 ()
 val  (PAT as PAT1) = PAT1 ()
 in (spacer'([ID_NO_EQ, COLON, TYP, AS, PAT]))
end)
 in ( LrTable.NT 90, ( result, ID_NO_EQ1left, PAT1right), rest671)
end
|  ( 201, ( ( _, ( MlyValue.PLABEL PLABEL1, PLABEL1left, PLABEL1right)
) :: rest671)) => let val  result = MlyValue.PLABELS (fn _ => let val 
 (PLABEL as PLABEL1) = PLABEL1 ()
 in (PLABEL)
end)
 in ( LrTable.NT 91, ( result, PLABEL1left, PLABEL1right), rest671)

end
|  ( 202, ( ( _, ( MlyValue.PLABELS PLABELS1, _, PLABELS1right)) :: (
 _, ( MlyValue.COMMA COMMA1, _, _)) :: ( _, ( MlyValue.PLABEL PLABEL1,
 PLABEL1left, _)) :: rest671)) => let val  result = MlyValue.PLABELS
 (fn _ => let val  (PLABEL as PLABEL1) = PLABEL1 ()
 val  (COMMA as COMMA1) = COMMA1 ()
 val  (PLABELS as PLABELS1) = PLABELS1 ()
 in (spacer'([PLABEL, COMMA, PLABELS]))
end)
 in ( LrTable.NT 91, ( result, PLABEL1left, PLABELS1right), rest671)

end
|  ( 203, ( ( _, ( MlyValue.DOTTED_WILDCARD DOTTED_WILDCARD1, 
DOTTED_WILDCARD1left, DOTTED_WILDCARD1right)) :: rest671)) => let val 
 result = MlyValue.PLABELS (fn _ => let val  (DOTTED_WILDCARD as 
DOTTED_WILDCARD1) = DOTTED_WILDCARD1 ()
 in (DOTTED_WILDCARD)
end)
 in ( LrTable.NT 91, ( result, DOTTED_WILDCARD1left, 
DOTTED_WILDCARD1right), rest671)
end
|  ( 204, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.STR_DEC STR_DEC1, _, _)) :: ( _, ( MlyValue.STRUCT STRUCT1, 
STRUCT1left, _)) :: rest671)) => let val  result = MlyValue.STR_EXP
 (fn _ => let val  (STRUCT as STRUCT1) = STRUCT1 ()
 val  (STR_DEC as STR_DEC1) = STR_DEC1 ()
 val  (END as END1) = END1 ()
 in (STRUCT ^ " " ^ STR_DEC ^ " " ^ END)
end)
 in ( LrTable.NT 52, ( result, STRUCT1left, END1right), rest671)
end
|  ( 205, ( ( _, ( MlyValue.LONG_STR_ID LONG_STR_ID1, LONG_STR_ID1left
, LONG_STR_ID1right)) :: rest671)) => let val  result = 
MlyValue.STR_EXP (fn _ => let val  (LONG_STR_ID as LONG_STR_ID1) = 
LONG_STR_ID1 ()
 in (LONG_STR_ID)
end)
 in ( LrTable.NT 52, ( result, LONG_STR_ID1left, LONG_STR_ID1right), 
rest671)
end
|  ( 206, ( ( _, ( MlyValue.ARG_FCT ARG_FCT1, _, ARG_FCT1right)) :: (
 _, ( MlyValue.FUN_ID FUN_ID1, FUN_ID1left, _)) :: rest671)) => let
 val  result = MlyValue.STR_EXP (fn _ => let val  (FUN_ID as FUN_ID1)
 = FUN_ID1 ()
 val  (ARG_FCT as ARG_FCT1) = ARG_FCT1 ()
 in (spacer'([FUN_ID, ARG_FCT]))
end)
 in ( LrTable.NT 52, ( result, FUN_ID1left, ARG_FCT1right), rest671)

end
|  ( 207, ( ( _, ( MlyValue.SIG_EXP SIG_EXP1, _, SIG_EXP1right)) :: (
 _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.STR_EXP 
STR_EXP1, STR_EXP1left, _)) :: rest671)) => let val  result = 
MlyValue.STR_EXP (fn _ => let val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 in (STR_EXP ^ " " ^ COLON ^ " " ^ SIG_EXP)
end)
 in ( LrTable.NT 52, ( result, STR_EXP1left, SIG_EXP1right), rest671)

end
|  ( 208, ( ( _, ( MlyValue.SIG_EXP SIG_EXP1, _, SIG_EXP1right)) :: (
 _, ( MlyValue.COLONGT COLONGT1, _, _)) :: ( _, ( MlyValue.STR_EXP 
STR_EXP1, STR_EXP1left, _)) :: rest671)) => let val  result = 
MlyValue.STR_EXP (fn _ => let val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 val  (COLONGT as COLONGT1) = COLONGT1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 in (STR_EXP ^ " " ^ COLONGT ^ " " ^ SIG_EXP)
end)
 in ( LrTable.NT 52, ( result, STR_EXP1left, SIG_EXP1right), rest671)

end
|  ( 209, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.STR_EXP STR_EXP1, _, _)) :: ( _, ( MlyValue.IN IN1, _, _)) ::
 ( _, ( MlyValue.STR_DEC STR_DEC1, _, _)) :: ( _, ( MlyValue.LET LET1,
 LET1left, _)) :: rest671)) => let val  result = MlyValue.STR_EXP (fn
 _ => let val  (LET as LET1) = LET1 ()
 val  (STR_DEC as STR_DEC1) = STR_DEC1 ()
 val  (IN as IN1) = IN1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 val  (END as END1) = END1 ()
 in (spacer'([LET, STR_DEC, IN, STR_EXP, END]))
end)
 in ( LrTable.NT 52, ( result, LET1left, END1right), rest671)
end
|  ( 210, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.STR_DEC STR_DEC1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1,
 LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.ARG_FCT
 (fn _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_DEC as STR_DEC1) = STR_DEC1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, STR_DEC, RPAREN]))
end)
 in ( LrTable.NT 53, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 211, ( ( _, ( MlyValue.RPAREN RPAREN1, _, RPAREN1right)) :: ( _, 
( MlyValue.STR_EXP STR_EXP1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1,
 LPAREN1left, _)) :: rest671)) => let val  result = MlyValue.ARG_FCT
 (fn _ => let val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 in (spacer'([LPAREN, STR_EXP, RPAREN]))
end)
 in ( LrTable.NT 53, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 212, ( ( _, ( MlyValue.ARG_FCT ARG_FCT1, _, ARG_FCT1right)) :: (
 _, ( MlyValue.RPAREN RPAREN1, _, _)) :: ( _, ( MlyValue.STR_DEC 
STR_DEC1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.ARG_FCT (fn _ => let val 
 (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_DEC as STR_DEC1) = STR_DEC1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (ARG_FCT as ARG_FCT1) = ARG_FCT1 ()
 in (spacer'([LPAREN, STR_DEC, RPAREN, ARG_FCT]))
end)
 in ( LrTable.NT 53, ( result, LPAREN1left, ARG_FCT1right), rest671)

end
|  ( 213, ( ( _, ( MlyValue.ARG_FCT ARG_FCT1, _, ARG_FCT1right)) :: (
 _, ( MlyValue.RPAREN RPAREN1, _, _)) :: ( _, ( MlyValue.STR_EXP 
STR_EXP1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.ARG_FCT (fn _ => let val 
 (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (ARG_FCT as ARG_FCT1) = ARG_FCT1 ()
 in (spacer'([LPAREN, STR_EXP, RPAREN, ARG_FCT]))
end)
 in ( LrTable.NT 53, ( result, LPAREN1left, ARG_FCT1right), rest671)

end
|  ( 214, ( ( _, ( MlyValue.DEC' DEC'1, DEC'1left, DEC'1right)) :: 
rest671)) => let val  result = MlyValue.STR_DEC' (fn _ => let val  (
DEC' as DEC'1) = DEC'1 ()
 in (DEC')
end)
 in ( LrTable.NT 54, ( result, DEC'1left, DEC'1right), rest671)
end
|  ( 215, ( ( _, ( MlyValue.STR_BIND STR_BIND1, _, STR_BIND1right)) ::
 ( _, ( MlyValue.STRUCTURE STRUCTURE1, STRUCTURE1left, _)) :: rest671)
) => let val  result = MlyValue.STR_DEC' (fn _ => let val  (STRUCTURE
 as STRUCTURE1) = STRUCTURE1 ()
 val  (STR_BIND as STR_BIND1) = STR_BIND1 ()
 in (spacer'([STRUCTURE, STR_BIND]))
end)
 in ( LrTable.NT 54, ( result, STRUCTURE1left, STR_BIND1right), 
rest671)
end
|  ( 216, ( ( _, ( MlyValue.FUN_BIND FUN_BIND1, _, FUN_BIND1right)) ::
 ( _, ( MlyValue.FUNCTOR FUNCTOR1, FUNCTOR1left, _)) :: rest671)) =>
 let val  result = MlyValue.STR_DEC' (fn _ => let val  (FUNCTOR as 
FUNCTOR1) = FUNCTOR1 ()
 val  (FUN_BIND as FUN_BIND1) = FUN_BIND1 ()
 in (spacer'([FUNCTOR, FUN_BIND]))
end)
 in ( LrTable.NT 54, ( result, FUNCTOR1left, FUN_BIND1right), rest671)

end
|  ( 217, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.STR_DEC STR_DEC2, _, _)) :: ( _, ( MlyValue.IN IN1, _, _)) ::
 ( _, ( MlyValue.STR_DEC STR_DEC1, _, _)) :: ( _, ( MlyValue.LOCAL 
LOCAL1, LOCAL1left, _)) :: rest671)) => let val  result = 
MlyValue.STR_DEC' (fn _ => let val  (LOCAL as LOCAL1) = LOCAL1 ()
 val  STR_DEC1 = STR_DEC1 ()
 val  (IN as IN1) = IN1 ()
 val  STR_DEC2 = STR_DEC2 ()
 val  (END as END1) = END1 ()
 in (spacer'([LOCAL, STR_DEC1, IN, STR_DEC2, END]))
end)
 in ( LrTable.NT 54, ( result, LOCAL1left, END1right), rest671)
end
|  ( 218, ( ( _, ( MlyValue.STR_DEC STR_DEC1, _, STR_DEC1right)) :: (
 _, ( MlyValue.STR_DEC' STR_DEC'1, STR_DEC'1left, _)) :: rest671)) =>
 let val  result = MlyValue.STR_DEC (fn _ => let val  (STR_DEC' as 
STR_DEC'1) = STR_DEC'1 ()
 val  (STR_DEC as STR_DEC1) = STR_DEC1 ()
 in (spacer'([STR_DEC', STR_DEC]))
end)
 in ( LrTable.NT 55, ( result, STR_DEC'1left, STR_DEC1right), rest671)

end
|  ( 219, ( ( _, ( MlyValue.STR_DEC STR_DEC1, _, STR_DEC1right)) :: (
 _, ( MlyValue.SEMICOLON SEMICOLON1, SEMICOLON1left, _)) :: rest671))
 => let val  result = MlyValue.STR_DEC (fn _ => let val  (SEMICOLON
 as SEMICOLON1) = SEMICOLON1 ()
 val  (STR_DEC as STR_DEC1) = STR_DEC1 ()
 in (spacer'([SEMICOLON, STR_DEC]))
end)
 in ( LrTable.NT 55, ( result, SEMICOLON1left, STR_DEC1right), rest671
)
end
|  ( 220, ( rest671)) => let val  result = MlyValue.STR_DEC (fn _ => (
""))
 in ( LrTable.NT 55, ( result, defaultPos, defaultPos), rest671)
end
|  ( 221, ( ( _, ( MlyValue.S_DECS S_DECS1, _, S_DECS1right)) :: ( _, 
( MlyValue.S_DEC' S_DEC'1, S_DEC'1left, _)) :: rest671)) => let val  
result = MlyValue.S_DECS (fn _ => let val  (S_DEC' as S_DEC'1) = 
S_DEC'1 ()
 val  (S_DECS as S_DECS1) = S_DECS1 ()
 in (spacer'([S_DEC', S_DECS]))
end)
 in ( LrTable.NT 56, ( result, S_DEC'1left, S_DECS1right), rest671)

end
|  ( 222, ( ( _, ( MlyValue.S_DECS S_DECS1, _, S_DECS1right)) :: ( _, 
( MlyValue.SEMICOLON SEMICOLON1, SEMICOLON1left, _)) :: rest671)) =>
 let val  result = MlyValue.S_DECS (fn _ => let val  (SEMICOLON as 
SEMICOLON1) = SEMICOLON1 ()
 val  (S_DECS as S_DECS1) = S_DECS1 ()
 in (spacer'([SEMICOLON, S_DECS]))
end)
 in ( LrTable.NT 56, ( result, SEMICOLON1left, S_DECS1right), rest671)

end
|  ( 223, ( rest671)) => let val  result = MlyValue.S_DECS (fn _ => (
""))
 in ( LrTable.NT 56, ( result, defaultPos, defaultPos), rest671)
end
|  ( 224, ( ( _, ( MlyValue.STR_BIND STR_BIND1, _, STR_BIND1right)) ::
 ( _, ( MlyValue.STRUCTURE STRUCTURE1, STRUCTURE1left, _)) :: rest671)
) => let val  result = MlyValue.S_DEC' (fn _ => let val  (STRUCTURE
 as STRUCTURE1) = STRUCTURE1 ()
 val  (STR_BIND as STR_BIND1) = STR_BIND1 ()
 in (spacer'([STRUCTURE, STR_BIND]))
end)
 in ( LrTable.NT 58, ( result, STRUCTURE1left, STR_BIND1right), 
rest671)
end
|  ( 225, ( ( _, ( MlyValue.SIG_BIND SIG_BIND1, _, SIG_BIND1right)) ::
 ( _, ( MlyValue.SIGNATURE SIGNATURE1, SIGNATURE1left, _)) :: rest671)
) => let val  result = MlyValue.S_DEC' (fn _ => let val  (SIGNATURE
 as SIGNATURE1) = SIGNATURE1 ()
 val  (SIG_BIND as SIG_BIND1) = SIG_BIND1 ()
 in (spacer'([SIGNATURE, SIG_BIND]))
end)
 in ( LrTable.NT 58, ( result, SIGNATURE1left, SIG_BIND1right), 
rest671)
end
|  ( 226, ( ( _, ( MlyValue.FUN_BIND FUN_BIND1, _, FUN_BIND1right)) ::
 ( _, ( MlyValue.FUNCTOR FUNCTOR1, FUNCTOR1left, _)) :: rest671)) =>
 let val  result = MlyValue.S_DEC' (fn _ => let val  (FUNCTOR as 
FUNCTOR1) = FUNCTOR1 ()
 val  (FUN_BIND as FUN_BIND1) = FUN_BIND1 ()
 in (spacer'([FUNCTOR, FUN_BIND]))
end)
 in ( LrTable.NT 58, ( result, FUNCTOR1left, FUN_BIND1right), rest671)

end
|  ( 227, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.S_DECS S_DECS2, _, _)) :: ( _, ( MlyValue.IN IN1, _, _)) :: (
 _, ( MlyValue.S_DECS S_DECS1, _, _)) :: ( _, ( MlyValue.LOCAL LOCAL1,
 LOCAL1left, _)) :: rest671)) => let val  result = MlyValue.S_DEC' (fn
 _ => let val  (LOCAL as LOCAL1) = LOCAL1 ()
 val  (S_DECS as S_DECS1) = S_DECS1 ()
 val  (IN as IN1) = IN1 ()
 val  S_DECS2 = S_DECS2 ()
 val  (END as END1) = END1 ()
 in (spacer'([LOCAL, S_DECS, IN, S_DECS, END]))
end)
 in ( LrTable.NT 58, ( result, LOCAL1left, END1right), rest671)
end
|  ( 228, ( ( _, ( MlyValue.DEC' DEC'1, DEC'1left, DEC'1right)) :: 
rest671)) => let val  result = MlyValue.S_DEC' (fn _ => let val  (DEC'
 as DEC'1) = DEC'1 ()
 in (DEC')
end)
 in ( LrTable.NT 58, ( result, DEC'1left, DEC'1right), rest671)
end
|  ( 229, ( ( _, ( MlyValue.S_DEC' S_DEC'1, S_DEC'1left, S_DEC'1right)
) :: rest671)) => let val  result = MlyValue.S_DEC (fn _ => let val  (
S_DEC' as S_DEC'1) = S_DEC'1 ()
 in (S_DEC')
end)
 in ( LrTable.NT 57, ( result, S_DEC'1left, S_DEC'1right), rest671)

end
|  ( 230, ( ( _, ( MlyValue.S_DEC S_DEC1, _, S_DEC1right)) :: ( _, ( 
MlyValue.S_DEC' S_DEC'1, S_DEC'1left, _)) :: rest671)) => let val  
result = MlyValue.S_DEC (fn _ => let val  (S_DEC' as S_DEC'1) = 
S_DEC'1 ()
 val  (S_DEC as S_DEC1) = S_DEC1 ()
 in (spacer'([S_DEC', S_DEC]))
end)
 in ( LrTable.NT 57, ( result, S_DEC'1left, S_DEC1right), rest671)
end
|  ( 231, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.STR_ID 
STR_ID1, STR_ID1left, _)) :: rest671)) => let val  result = 
MlyValue.STR_BIND' (fn _ => let val  (STR_ID as STR_ID1) = STR_ID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (spacer'([STR_ID, EQUALOP, STR_EXP]))
end)
 in ( LrTable.NT 59, ( result, STR_ID1left, STR_EXP1right), rest671)

end
|  ( 232, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_EXP 
SIG_EXP1, _, _)) :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( 
MlyValue.STR_ID STR_ID1, STR_ID1left, _)) :: rest671)) => let val  
result = MlyValue.STR_BIND' (fn _ => let val  (STR_ID as STR_ID1) = 
STR_ID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([STR_ID, COLON, SIG_EXP, 
                                                                          EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 59, ( result, STR_ID1left, STR_EXP1right), rest671)

end
|  ( 233, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_EXP 
SIG_EXP1, _, _)) :: ( _, ( MlyValue.COLONGT COLONGT1, _, _)) :: ( _, (
 MlyValue.STR_ID STR_ID1, STR_ID1left, _)) :: rest671)) => let val  
result = MlyValue.STR_BIND' (fn _ => let val  (STR_ID as STR_ID1) = 
STR_ID1 ()
 val  (COLONGT as COLONGT1) = COLONGT1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([STR_ID, COLONGT, SIG_EXP, 
                                                                          EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 59, ( result, STR_ID1left, STR_EXP1right), rest671)

end
|  ( 234, ( ( _, ( MlyValue.STR_BIND' STR_BIND'1, STR_BIND'1left, 
STR_BIND'1right)) :: rest671)) => let val  result = MlyValue.STR_BIND
 (fn _ => let val  (STR_BIND' as STR_BIND'1) = STR_BIND'1 ()
 in (STR_BIND')
end)
 in ( LrTable.NT 60, ( result, STR_BIND'1left, STR_BIND'1right), 
rest671)
end
|  ( 235, ( ( _, ( MlyValue.STR_BIND STR_BIND1, _, STR_BIND1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.STR_BIND' 
STR_BIND'1, STR_BIND'1left, _)) :: rest671)) => let val  result = 
MlyValue.STR_BIND (fn _ => let val  (STR_BIND' as STR_BIND'1) = 
STR_BIND'1 ()
 val  (AND as AND1) = AND1 ()
 val  (STR_BIND as STR_BIND1) = STR_BIND1 ()
 in (spacer'([STR_BIND', AND, STR_BIND]))
end)
 in ( LrTable.NT 60, ( result, STR_BIND'1left, STR_BIND1right), 
rest671)
end
|  ( 236, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.LONG_TYP_CON 
LONG_TYP_CON1, _, _)) :: ( _, ( MlyValue.TYPE TYPE1, TYPE1left, _)) ::
 rest671)) => let val  result = MlyValue.TYP_REFINE' (fn _ => let val 
 (TYPE as TYPE1) = TYPE1 ()
 val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([TYPE, LONG_TYP_CON, EQUALOP, TYP]))
end)
 in ( LrTable.NT 61, ( result, TYPE1left, TYP1right), rest671)
end
|  ( 237, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.LONG_TYP_CON 
LONG_TYP_CON1, _, _)) :: ( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, _,
 _)) :: ( _, ( MlyValue.TYPE TYPE1, TYPE1left, _)) :: rest671)) => let
 val  result = MlyValue.TYP_REFINE' (fn _ => let val  (TYPE as TYPE1)
 = TYPE1 ()
 val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = TYP_VAR_SEQ1 ()
 val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([TYPE, TYP_VAR_SEQ, LONG_TYP_CON, EQUALOP, TYP]))
end)
 in ( LrTable.NT 61, ( result, TYPE1left, TYP1right), rest671)
end
|  ( 238, ( ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON2, _, 
LONG_TYP_CON2right)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: (
 _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, LONG_TYP_CON1left, _)) :: 
rest671)) => let val  result = MlyValue.TYP_REFINE' (fn _ => let val 
 (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  LONG_TYP_CON2 = LONG_TYP_CON2 ()
 in (spacer'[LONG_TYP_CON, EQUALOP, LONG_TYP_CON])
end)
 in ( LrTable.NT 61, ( result, LONG_TYP_CON1left, LONG_TYP_CON2right),
 rest671)
end
|  ( 239, ( ( _, ( MlyValue.TYP_REFINE' TYP_REFINE'1, TYP_REFINE'1left
, TYP_REFINE'1right)) :: rest671)) => let val  result = 
MlyValue.TYP_REFINE (fn _ => let val  (TYP_REFINE' as TYP_REFINE'1) = 
TYP_REFINE'1 ()
 in (TYP_REFINE')
end)
 in ( LrTable.NT 62, ( result, TYP_REFINE'1left, TYP_REFINE'1right), 
rest671)
end
|  ( 240, ( ( _, ( MlyValue.TYP_REFINE TYP_REFINE1, _, 
TYP_REFINE1right)) :: ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( 
MlyValue.TYP_REFINE' TYP_REFINE'1, TYP_REFINE'1left, _)) :: rest671))
 => let val  result = MlyValue.TYP_REFINE (fn _ => let val  (
TYP_REFINE' as TYP_REFINE'1) = TYP_REFINE'1 ()
 val  (AND as AND1) = AND1 ()
 val  (TYP_REFINE as TYP_REFINE1) = TYP_REFINE1 ()
 in (spacer'([TYP_REFINE', AND, TYP_REFINE]))
end)
 in ( LrTable.NT 62, ( result, TYP_REFINE'1left, TYP_REFINE1right), 
rest671)
end
|  ( 241, ( ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON2, _, 
LONG_TYP_CON2right)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: (
 _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, LONG_TYP_CON1left, _)) :: 
rest671)) => let val  result = MlyValue.LONG_TY_CON_EQ_SEQ (fn _ =>
 let val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  LONG_TYP_CON2 = LONG_TYP_CON2 ()
 in (spacer'([LONG_TYP_CON, EQUALOP, LONG_TYP_CON]))
end)
 in ( LrTable.NT 63, ( result, LONG_TYP_CON1left, LONG_TYP_CON2right),
 rest671)
end
|  ( 242, ( ( _, ( MlyValue.LONG_TY_CON_EQ_SEQ LONG_TY_CON_EQ_SEQ1, _,
 LONG_TY_CON_EQ_SEQ1right)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)
) :: ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, LONG_TYP_CON1left, _)
) :: rest671)) => let val  result = MlyValue.LONG_TY_CON_EQ_SEQ (fn _
 => let val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (LONG_TY_CON_EQ_SEQ as LONG_TY_CON_EQ_SEQ1) = 
LONG_TY_CON_EQ_SEQ1 ()
 in (spacer'([LONG_TYP_CON, EQUALOP, LONG_TY_CON_EQ_SEQ]))
end)
 in ( LrTable.NT 63, ( result, LONG_TYP_CON1left, 
LONG_TY_CON_EQ_SEQ1right), rest671)
end
|  ( 243, ( ( _, ( MlyValue.LONG_STR_ID LONG_STR_ID2, _, 
LONG_STR_ID2right)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _
, ( MlyValue.LONG_STR_ID LONG_STR_ID1, LONG_STR_ID1left, _)) :: 
rest671)) => let val  result = MlyValue.LONG_STR_ID_EQ_SEQ (fn _ =>
 let val  (LONG_STR_ID as LONG_STR_ID1) = LONG_STR_ID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  LONG_STR_ID2 = LONG_STR_ID2 ()
 in (spacer'([LONG_STR_ID, EQUALOP, LONG_STR_ID]))
end)
 in ( LrTable.NT 64, ( result, LONG_STR_ID1left, LONG_STR_ID2right), 
rest671)
end
|  ( 244, ( ( _, ( MlyValue.LONG_STR_ID_EQ_SEQ LONG_STR_ID_EQ_SEQ1, _,
 LONG_STR_ID_EQ_SEQ1right)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)
) :: ( _, ( MlyValue.LONG_STR_ID LONG_STR_ID1, LONG_STR_ID1left, _))
 :: rest671)) => let val  result = MlyValue.LONG_STR_ID_EQ_SEQ (fn _
 => let val  (LONG_STR_ID as LONG_STR_ID1) = LONG_STR_ID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (LONG_STR_ID_EQ_SEQ as LONG_STR_ID_EQ_SEQ1) = 
LONG_STR_ID_EQ_SEQ1 ()
 in (spacer'([LONG_STR_ID, EQUALOP, LONG_STR_ID_EQ_SEQ]))
end)
 in ( LrTable.NT 64, ( result, LONG_STR_ID1left, 
LONG_STR_ID_EQ_SEQ1right), rest671)
end
|  ( 245, ( ( _, ( MlyValue.SIG_ID SIG_ID1, SIG_ID1left, SIG_ID1right)
) :: rest671)) => let val  result = MlyValue.SIG_ID_SPCE_SEQ (fn _ =>
 let val  (SIG_ID as SIG_ID1) = SIG_ID1 ()
 in (SIG_ID)
end)
 in ( LrTable.NT 65, ( result, SIG_ID1left, SIG_ID1right), rest671)

end
|  ( 246, ( ( _, ( MlyValue.SIG_ID_SPCE_SEQ SIG_ID_SPCE_SEQ1, _, 
SIG_ID_SPCE_SEQ1right)) :: ( _, ( MlyValue.SIG_ID SIG_ID1, SIG_ID1left
, _)) :: rest671)) => let val  result = MlyValue.SIG_ID_SPCE_SEQ (fn _
 => let val  (SIG_ID as SIG_ID1) = SIG_ID1 ()
 val  (SIG_ID_SPCE_SEQ as SIG_ID_SPCE_SEQ1) = SIG_ID_SPCE_SEQ1 ()
 in (SIG_ID ^ " " ^ SIG_ID_SPCE_SEQ)
end)
 in ( LrTable.NT 65, ( result, SIG_ID1left, SIG_ID_SPCE_SEQ1right), 
rest671)
end
|  ( 247, ( ( _, ( MlyValue.END END1, _, END1right)) :: ( _, ( 
MlyValue.SPEC SPEC1, _, _)) :: ( _, ( MlyValue.SIG SIG1, SIG1left, _))
 :: rest671)) => let val  result = MlyValue.SIG_EXP (fn _ => let val 
 (SIG as SIG1) = SIG1 ()
 val  (SPEC as SPEC1) = SPEC1 ()
 val  (END as END1) = END1 ()
 in (spacer'([SIG, SPEC, END]))
end)
 in ( LrTable.NT 66, ( result, SIG1left, END1right), rest671)
end
|  ( 248, ( ( _, ( MlyValue.SIG_ID SIG_ID1, SIG_ID1left, SIG_ID1right)
) :: rest671)) => let val  result = MlyValue.SIG_EXP (fn _ => let val 
 (SIG_ID as SIG_ID1) = SIG_ID1 ()
 in (SIG_ID)
end)
 in ( LrTable.NT 66, ( result, SIG_ID1left, SIG_ID1right), rest671)

end
|  ( 249, ( ( _, ( MlyValue.TYP_REFINE TYP_REFINE1, _, 
TYP_REFINE1right)) :: ( _, ( MlyValue.WHERE WHERE1, _, _)) :: ( _, ( 
MlyValue.SIG_EXP SIG_EXP1, SIG_EXP1left, _)) :: rest671)) => let val  
result = MlyValue.SIG_EXP (fn _ => let val  (SIG_EXP as SIG_EXP1) = 
SIG_EXP1 ()
 val  (WHERE as WHERE1) = WHERE1 ()
 val  (TYP_REFINE as TYP_REFINE1) = TYP_REFINE1 ()
 in (spacer'([SIG_EXP, WHERE, TYP_REFINE]))
end)
 in ( LrTable.NT 66, ( result, SIG_EXP1left, TYP_REFINE1right), 
rest671)
end
|  ( 250, ( ( _, ( MlyValue.SIG_BIND SIG_BIND1, _, SIG_BIND1right)) ::
 ( _, ( MlyValue.SIGNATURE SIGNATURE1, SIGNATURE1left, _)) :: rest671)
) => let val  result = MlyValue.SIG_DEC (fn _ => let val  (SIGNATURE
 as SIGNATURE1) = SIGNATURE1 ()
 val  (SIG_BIND as SIG_BIND1) = SIG_BIND1 ()
 in (SIGNATURE ^ " " ^ SIG_BIND)
end)
 in ( LrTable.NT 67, ( result, SIGNATURE1left, SIG_BIND1right), 
rest671)
end
|  ( 251, ( ( _, ( MlyValue.SIG_EXP SIG_EXP1, _, SIG_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_ID 
SIG_ID1, SIG_ID1left, _)) :: rest671)) => let val  result = 
MlyValue.SIG_BIND (fn _ => let val  (SIG_ID as SIG_ID1) = SIG_ID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 in (spacer'([SIG_ID, EQUALOP, SIG_EXP]))
end)
 in ( LrTable.NT 68, ( result, SIG_ID1left, SIG_EXP1right), rest671)

end
|  ( 252, ( ( _, ( MlyValue.SIG_BIND SIG_BIND1, _, SIG_BIND1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.SIG_EXP SIG_EXP1,
 _, _)) :: ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( 
MlyValue.SIG_ID SIG_ID1, SIG_ID1left, _)) :: rest671)) => let val  
result = MlyValue.SIG_BIND (fn _ => let val  (SIG_ID as SIG_ID1) = 
SIG_ID1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (AND as AND1) = AND1 ()
 val  (SIG_BIND as SIG_BIND1) = SIG_BIND1 ()
 in (spacer'([SIG_ID, EQUALOP, SIG_EXP, AND, SIG_BIND]))
end)
 in ( LrTable.NT 68, ( result, SIG_ID1left, SIG_BIND1right), rest671)

end
|  ( 253, ( ( _, ( MlyValue.VAL_DESC VAL_DESC1, _, VAL_DESC1right)) ::
 ( _, ( MlyValue.VAL VAL1, VAL1left, _)) :: rest671)) => let val  
result = MlyValue.SPEC' (fn _ => let val  (VAL as VAL1) = VAL1 ()
 val  (VAL_DESC as VAL_DESC1) = VAL_DESC1 ()
 in (VAL ^ " " ^ VAL_DESC)
end)
 in ( LrTable.NT 69, ( result, VAL1left, VAL_DESC1right), rest671)
end
|  ( 254, ( ( _, ( MlyValue.TYP_DESC TYP_DESC1, _, TYP_DESC1right)) ::
 ( _, ( MlyValue.TYPE TYPE1, TYPE1left, _)) :: rest671)) => let val  
result = MlyValue.SPEC' (fn _ => let val  (TYPE as TYPE1) = TYPE1 ()
 val  (TYP_DESC as TYP_DESC1) = TYP_DESC1 ()
 in (TYPE ^ " " ^ TYP_DESC)
end)
 in ( LrTable.NT 69, ( result, TYPE1left, TYP_DESC1right), rest671)

end
|  ( 255, ( ( _, ( MlyValue.TYP_DESC TYP_DESC1, _, TYP_DESC1right)) ::
 ( _, ( MlyValue.EQTYPE EQTYPE1, EQTYPE1left, _)) :: rest671)) => let
 val  result = MlyValue.SPEC' (fn _ => let val  (EQTYPE as EQTYPE1) = 
EQTYPE1 ()
 val  (TYP_DESC as TYP_DESC1) = TYP_DESC1 ()
 in (EQTYPE ^ " " ^ TYP_DESC)
end)
 in ( LrTable.NT 69, ( result, EQTYPE1left, TYP_DESC1right), rest671)

end
|  ( 256, ( ( _, ( MlyValue.DAT_DESC DAT_DESC1, _, DAT_DESC1right)) ::
 ( _, ( MlyValue.DATATYPE DATATYPE1, DATATYPE1left, _)) :: rest671))
 => let val  result = MlyValue.SPEC' (fn _ => let val  (DATATYPE as 
DATATYPE1) = DATATYPE1 ()
 val  (DAT_DESC as DAT_DESC1) = DAT_DESC1 ()
 in (DATATYPE ^ " " ^ DAT_DESC)
end)
 in ( LrTable.NT 69, ( result, DATATYPE1left, DAT_DESC1right), rest671
)
end
|  ( 257, ( ( _, ( MlyValue.LONG_TYP_CON LONG_TYP_CON1, _, 
LONG_TYP_CON1right)) :: ( _, ( MlyValue.DATATYPE DATATYPE2, _, _)) :: 
( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON 
TYP_CON1, _, _)) :: ( _, ( MlyValue.DATATYPE DATATYPE1, DATATYPE1left,
 _)) :: rest671)) => let val  result = MlyValue.SPEC' (fn _ => let
 val  (DATATYPE as DATATYPE1) = DATATYPE1 ()
 val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  DATATYPE2 = DATATYPE2 ()
 val  (LONG_TYP_CON as LONG_TYP_CON1) = LONG_TYP_CON1 ()
 in (spacer'([DATATYPE, TYP_CON, EQUALOP, DATATYPE, LONG_TYP_CON]))

end)
 in ( LrTable.NT 69, ( result, DATATYPE1left, LONG_TYP_CON1right), 
rest671)
end
|  ( 258, ( ( _, ( MlyValue.EX_DESC EX_DESC1, _, EX_DESC1right)) :: (
 _, ( MlyValue.EXCEPTION EXCEPTION1, EXCEPTION1left, _)) :: rest671))
 => let val  result = MlyValue.SPEC' (fn _ => let val  (EXCEPTION as 
EXCEPTION1) = EXCEPTION1 ()
 val  (EX_DESC as EX_DESC1) = EX_DESC1 ()
 in (EXCEPTION ^ " " ^ EX_DESC)
end)
 in ( LrTable.NT 69, ( result, EXCEPTION1left, EX_DESC1right), rest671
)
end
|  ( 259, ( ( _, ( MlyValue.STR_DESC STR_DESC1, _, STR_DESC1right)) ::
 ( _, ( MlyValue.STRUCTURE STRUCTURE1, STRUCTURE1left, _)) :: rest671)
) => let val  result = MlyValue.SPEC' (fn _ => let val  (STRUCTURE as 
STRUCTURE1) = STRUCTURE1 ()
 val  (STR_DESC as STR_DESC1) = STR_DESC1 ()
 in (STRUCTURE ^ " " ^ STR_DESC)
end)
 in ( LrTable.NT 69, ( result, STRUCTURE1left, STR_DESC1right), 
rest671)
end
|  ( 260, ( ( _, ( MlyValue.SIG_EXP SIG_EXP1, _, SIG_EXP1right)) :: (
 _, ( MlyValue.INCLUDE INCLUDE1, INCLUDE1left, _)) :: rest671)) => let
 val  result = MlyValue.SPEC' (fn _ => let val  (INCLUDE as INCLUDE1)
 = INCLUDE1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 in (INCLUDE ^ " " ^ SIG_EXP)
end)
 in ( LrTable.NT 69, ( result, INCLUDE1left, SIG_EXP1right), rest671)

end
|  ( 261, ( ( _, ( MlyValue.TYP_BIND TYP_BIND1, _, TYP_BIND1right)) ::
 ( _, ( MlyValue.TYPE TYPE1, TYPE1left, _)) :: rest671)) => let val  
result = MlyValue.SPEC' (fn _ => let val  (TYPE as TYPE1) = TYPE1 ()
 val  (TYP_BIND as TYP_BIND1) = TYP_BIND1 ()
 in (TYPE ^ " " ^ TYP_BIND)
end)
 in ( LrTable.NT 69, ( result, TYPE1left, TYP_BIND1right), rest671)

end
|  ( 262, ( ( _, ( MlyValue.SIG_ID_SPCE_SEQ SIG_ID_SPCE_SEQ1, _, 
SIG_ID_SPCE_SEQ1right)) :: ( _, ( MlyValue.INCLUDE INCLUDE1, 
INCLUDE1left, _)) :: rest671)) => let val  result = MlyValue.SPEC' (fn
 _ => let val  (INCLUDE as INCLUDE1) = INCLUDE1 ()
 val  (SIG_ID_SPCE_SEQ as SIG_ID_SPCE_SEQ1) = SIG_ID_SPCE_SEQ1 ()
 in (INCLUDE ^ " " ^ SIG_ID_SPCE_SEQ)
end)
 in ( LrTable.NT 69, ( result, INCLUDE1left, SIG_ID_SPCE_SEQ1right), 
rest671)
end
|  ( 263, ( ( _, ( MlyValue.LONG_TY_CON_EQ_SEQ LONG_TY_CON_EQ_SEQ1, _,
 LONG_TY_CON_EQ_SEQ1right)) :: ( _, ( MlyValue.TYPE TYPE1, _, _)) :: (
 _, ( MlyValue.SHARING SHARING1, SHARING1left, _)) :: rest671)) => let
 val  result = MlyValue.SPEC' (fn _ => let val  (SHARING as SHARING1)
 = SHARING1 ()
 val  (TYPE as TYPE1) = TYPE1 ()
 val  (LONG_TY_CON_EQ_SEQ as LONG_TY_CON_EQ_SEQ1) = 
LONG_TY_CON_EQ_SEQ1 ()
 in (spacer'([SHARING, TYPE, LONG_TY_CON_EQ_SEQ]))
end)
 in ( LrTable.NT 69, ( result, SHARING1left, LONG_TY_CON_EQ_SEQ1right)
, rest671)
end
|  ( 264, ( ( _, ( MlyValue.LONG_STR_ID_EQ_SEQ LONG_STR_ID_EQ_SEQ1, _,
 LONG_STR_ID_EQ_SEQ1right)) :: ( _, ( MlyValue.SHARING SHARING1, 
SHARING1left, _)) :: rest671)) => let val  result = MlyValue.SPEC' (fn
 _ => let val  (SHARING as SHARING1) = SHARING1 ()
 val  (LONG_STR_ID_EQ_SEQ as LONG_STR_ID_EQ_SEQ1) = 
LONG_STR_ID_EQ_SEQ1 ()
 in (spacer'([SHARING, LONG_STR_ID_EQ_SEQ]))
end)
 in ( LrTable.NT 69, ( result, SHARING1left, LONG_STR_ID_EQ_SEQ1right)
, rest671)
end
|  ( 265, ( rest671)) => let val  result = MlyValue.SPEC (fn _ => ("")
)
 in ( LrTable.NT 70, ( result, defaultPos, defaultPos), rest671)
end
|  ( 266, ( ( _, ( MlyValue.SPEC SPEC1, _, SPEC1right)) :: ( _, ( 
MlyValue.SPEC' SPEC'1, SPEC'1left, _)) :: rest671)) => let val  result
 = MlyValue.SPEC (fn _ => let val  (SPEC' as SPEC'1) = SPEC'1 ()
 val  (SPEC as SPEC1) = SPEC1 ()
 in (spacer'([SPEC', SPEC]))
end)
 in ( LrTable.NT 70, ( result, SPEC'1left, SPEC1right), rest671)
end
|  ( 267, ( ( _, ( MlyValue.SPEC SPEC1, _, SPEC1right)) :: ( _, ( 
MlyValue.SEMICOLON SEMICOLON1, SEMICOLON1left, _)) :: rest671)) => let
 val  result = MlyValue.SPEC (fn _ => let val  (SEMICOLON as 
SEMICOLON1) = SEMICOLON1 ()
 val  (SPEC as SPEC1) = SPEC1 ()
 in (spacer'([SEMICOLON, SPEC]))
end)
 in ( LrTable.NT 70, ( result, SEMICOLON1left, SPEC1right), rest671)

end
|  ( 268, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _
)) :: rest671)) => let val  result = MlyValue.VAL_DESC (fn _ => let
 val  (VID as VID1) = VID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (VID ^ " " ^ COLON ^ " " ^ TYP)
end)
 in ( LrTable.NT 71, ( result, VID1left, TYP1right), rest671)
end
|  ( 269, ( ( _, ( MlyValue.VAL_DESC VAL_DESC1, _, VAL_DESC1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.TYP TYP1, _, _))
 :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.VID VID1, 
VID1left, _)) :: rest671)) => let val  result = MlyValue.VAL_DESC (fn
 _ => let val  (VID as VID1) = VID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (AND as AND1) = AND1 ()
 val  (VAL_DESC as VAL_DESC1) = VAL_DESC1 ()
 in (VID ^ " " ^ COLON ^ " " ^ TYP ^ " " ^ AND ^ " " ^ VAL_DESC)
end)
 in ( LrTable.NT 71, ( result, VID1left, VAL_DESC1right), rest671)
end
|  ( 270, ( ( _, ( MlyValue.TYP_CON TYP_CON1, TYP_CON1left, 
TYP_CON1right)) :: rest671)) => let val  result = MlyValue.TYP_DESC'
 (fn _ => let val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 in (TYP_CON)
end)
 in ( LrTable.NT 72, ( result, TYP_CON1left, TYP_CON1right), rest671)

end
|  ( 271, ( ( _, ( MlyValue.TYP_CON TYP_CON1, _, TYP_CON1right)) :: (
 _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, TYP_VAR_SEQ1left, _)) :: 
rest671)) => let val  result = MlyValue.TYP_DESC' (fn _ => let val  (
TYP_VAR_SEQ as TYP_VAR_SEQ1) = TYP_VAR_SEQ1 ()
 val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 in (TYP_VAR_SEQ ^ " " ^ TYP_CON)
end)
 in ( LrTable.NT 72, ( result, TYP_VAR_SEQ1left, TYP_CON1right), 
rest671)
end
|  ( 272, ( ( _, ( MlyValue.TYP_DESC' TYP_DESC'1, TYP_DESC'1left, 
TYP_DESC'1right)) :: rest671)) => let val  result = MlyValue.TYP_DESC
 (fn _ => let val  (TYP_DESC' as TYP_DESC'1) = TYP_DESC'1 ()
 in (TYP_DESC')
end)
 in ( LrTable.NT 73, ( result, TYP_DESC'1left, TYP_DESC'1right), 
rest671)
end
|  ( 273, ( ( _, ( MlyValue.TYP_DESC TYP_DESC1, _, TYP_DESC1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.TYP_DESC' 
TYP_DESC'1, TYP_DESC'1left, _)) :: rest671)) => let val  result = 
MlyValue.TYP_DESC (fn _ => let val  (TYP_DESC' as TYP_DESC'1) = 
TYP_DESC'1 ()
 val  (AND as AND1) = AND1 ()
 val  (TYP_DESC as TYP_DESC1) = TYP_DESC1 ()
 in (spacer'([TYP_DESC', AND, TYP_DESC]))
end)
 in ( LrTable.NT 73, ( result, TYP_DESC'1left, TYP_DESC1right), 
rest671)
end
|  ( 274, ( ( _, ( MlyValue.CON_DESC CON_DESC1, _, CON_DESC1right)) ::
 ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON 
TYP_CON1, TYP_CON1left, _)) :: rest671)) => let val  result = 
MlyValue.DAT_DESC' (fn _ => let val  (TYP_CON as TYP_CON1) = TYP_CON1
 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (CON_DESC as CON_DESC1) = CON_DESC1 ()
 in (spacer'([TYP_CON, EQUALOP, CON_DESC]))
end)
 in ( LrTable.NT 74, ( result, TYP_CON1left, CON_DESC1right), rest671)

end
|  ( 275, ( ( _, ( MlyValue.CON_DESC CON_DESC1, _, CON_DESC1right)) ::
 ( _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.TYP_CON 
TYP_CON1, _, _)) :: ( _, ( MlyValue.TYP_VAR_SEQ TYP_VAR_SEQ1, 
TYP_VAR_SEQ1left, _)) :: rest671)) => let val  result = 
MlyValue.DAT_DESC' (fn _ => let val  (TYP_VAR_SEQ as TYP_VAR_SEQ1) = 
TYP_VAR_SEQ1 ()
 val  (TYP_CON as TYP_CON1) = TYP_CON1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (CON_DESC as CON_DESC1) = CON_DESC1 ()
 in (spacer'([TYP_VAR_SEQ, TYP_CON, EQUALOP, CON_DESC]))
end)
 in ( LrTable.NT 74, ( result, TYP_VAR_SEQ1left, CON_DESC1right), 
rest671)
end
|  ( 276, ( ( _, ( MlyValue.DAT_DESC' DAT_DESC'1, DAT_DESC'1left, 
DAT_DESC'1right)) :: rest671)) => let val  result = MlyValue.DAT_DESC
 (fn _ => let val  (DAT_DESC' as DAT_DESC'1) = DAT_DESC'1 ()
 in (DAT_DESC')
end)
 in ( LrTable.NT 75, ( result, DAT_DESC'1left, DAT_DESC'1right), 
rest671)
end
|  ( 277, ( ( _, ( MlyValue.DAT_DESC DAT_DESC1, _, DAT_DESC1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.DAT_DESC' 
DAT_DESC'1, DAT_DESC'1left, _)) :: rest671)) => let val  result = 
MlyValue.DAT_DESC (fn _ => let val  (DAT_DESC' as DAT_DESC'1) = 
DAT_DESC'1 ()
 val  (AND as AND1) = AND1 ()
 val  (DAT_DESC as DAT_DESC1) = DAT_DESC1 ()
 in (spacer'([DAT_DESC', AND, DAT_DESC]))
end)
 in ( LrTable.NT 75, ( result, DAT_DESC'1left, DAT_DESC1right), 
rest671)
end
|  ( 278, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671
)) => let val  result = MlyValue.CON_DESC (fn _ => let val  (VID as 
VID1) = VID1 ()
 in (VID)
end)
 in ( LrTable.NT 76, ( result, VID1left, VID1right), rest671)
end
|  ( 279, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _)) :: 
rest671)) => let val  result = MlyValue.CON_DESC (fn _ => let val  (
VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([VID, OF, TYP]))
end)
 in ( LrTable.NT 76, ( result, VID1left, TYP1right), rest671)
end
|  ( 280, ( ( _, ( MlyValue.CON_DESC CON_DESC1, _, CON_DESC1right)) ::
 ( _, ( MlyValue.BAR BAR1, _, _)) :: ( _, ( MlyValue.VID VID1, 
VID1left, _)) :: rest671)) => let val  result = MlyValue.CON_DESC (fn
 _ => let val  (VID as VID1) = VID1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (CON_DESC as CON_DESC1) = CON_DESC1 ()
 in (spacer'([VID, BAR, CON_DESC]))
end)
 in ( LrTable.NT 76, ( result, VID1left, CON_DESC1right), rest671)
end
|  ( 281, ( ( _, ( MlyValue.CON_DESC CON_DESC1, _, CON_DESC1right)) ::
 ( _, ( MlyValue.BAR BAR1, _, _)) :: ( _, ( MlyValue.TYP TYP1, _, _))
 :: ( _, ( MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, 
VID1left, _)) :: rest671)) => let val  result = MlyValue.CON_DESC (fn
 _ => let val  (VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (BAR as BAR1) = BAR1 ()
 val  (CON_DESC as CON_DESC1) = CON_DESC1 ()
 in (spacer'([VID, OF, TYP, BAR, CON_DESC]))
end)
 in ( LrTable.NT 76, ( result, VID1left, CON_DESC1right), rest671)
end
|  ( 282, ( ( _, ( MlyValue.VID VID1, VID1left, VID1right)) :: rest671
)) => let val  result = MlyValue.EX_DESC (fn _ => let val  (VID as 
VID1) = VID1 ()
 in (VID)
end)
 in ( LrTable.NT 77, ( result, VID1left, VID1right), rest671)
end
|  ( 283, ( ( _, ( MlyValue.TYP TYP1, _, TYP1right)) :: ( _, ( 
MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left, _)) :: 
rest671)) => let val  result = MlyValue.EX_DESC (fn _ => let val  (VID
 as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 in (spacer'([VID, OF, TYP]))
end)
 in ( LrTable.NT 77, ( result, VID1left, TYP1right), rest671)
end
|  ( 284, ( ( _, ( MlyValue.EX_DESC EX_DESC1, _, EX_DESC1right)) :: (
 _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left,
 _)) :: rest671)) => let val  result = MlyValue.EX_DESC (fn _ => let
 val  (VID as VID1) = VID1 ()
 val  (AND as AND1) = AND1 ()
 val  (EX_DESC as EX_DESC1) = EX_DESC1 ()
 in (spacer'([VID, AND, EX_DESC]))
end)
 in ( LrTable.NT 77, ( result, VID1left, EX_DESC1right), rest671)
end
|  ( 285, ( ( _, ( MlyValue.EX_DESC EX_DESC1, _, EX_DESC1right)) :: (
 _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.TYP TYP1, _, _)) ::
 ( _, ( MlyValue.OF OF1, _, _)) :: ( _, ( MlyValue.VID VID1, VID1left,
 _)) :: rest671)) => let val  result = MlyValue.EX_DESC (fn _ => let
 val  (VID as VID1) = VID1 ()
 val  (OF as OF1) = OF1 ()
 val  (TYP as TYP1) = TYP1 ()
 val  (AND as AND1) = AND1 ()
 val  (EX_DESC as EX_DESC1) = EX_DESC1 ()
 in (spacer'([VID, OF, TYP, AND, EX_DESC]))
end)
 in ( LrTable.NT 77, ( result, VID1left, EX_DESC1right), rest671)
end
|  ( 286, ( ( _, ( MlyValue.SIG_EXP SIG_EXP1, _, SIG_EXP1right)) :: (
 _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.VID VID1, 
VID1left, _)) :: rest671)) => let val  result = MlyValue.STR_DESC (fn
 _ => let val  (VID as VID1) = VID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 in (spacer'([VID, COLON, SIG_EXP]))
end)
 in ( LrTable.NT 78, ( result, VID1left, SIG_EXP1right), rest671)
end
|  ( 287, ( ( _, ( MlyValue.STR_DESC STR_DESC1, _, STR_DESC1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.SIG_EXP SIG_EXP1,
 _, _)) :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.VID
 VID1, VID1left, _)) :: rest671)) => let val  result = 
MlyValue.STR_DESC (fn _ => let val  (VID as VID1) = VID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (AND as AND1) = AND1 ()
 val  (STR_DESC as STR_DESC1) = STR_DESC1 ()
 in (spacer'([VID, COLON, SIG_EXP, AND, STR_DESC]))
end)
 in ( LrTable.NT 78, ( result, VID1left, STR_DESC1right), rest671)
end
|  ( 288, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.RPAREN 
RPAREN1, _, _)) :: ( _, ( MlyValue.SIG_EXP SIG_EXP1, _, _)) :: ( _, ( 
MlyValue.COLON COLON1, _, _)) :: ( _, ( MlyValue.STR_ID STR_ID1, _, _)
) :: ( _, ( MlyValue.LPAREN LPAREN1, _, _)) :: ( _, ( MlyValue.FUN_ID 
FUN_ID1, FUN_ID1left, _)) :: rest671)) => let val  result = 
MlyValue.FUN_BIND' (fn _ => let val  (FUN_ID as FUN_ID1) = FUN_ID1 ()
 val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_ID as STR_ID1) = STR_ID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([FUN_ID, LPAREN, STR_ID, COLON, SIG_EXP, RPAREN, EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 79, ( result, FUN_ID1left, STR_EXP1right), rest671)

end
|  ( 289, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_EXP 
SIG_EXP2, _, _)) :: ( _, ( MlyValue.COLON COLON2, _, _)) :: ( _, ( 
MlyValue.RPAREN RPAREN1, _, _)) :: ( _, ( MlyValue.SIG_EXP SIG_EXP1, _
, _)) :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( 
MlyValue.STR_ID STR_ID1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, _,
 _)) :: ( _, ( MlyValue.FUN_ID FUN_ID1, FUN_ID1left, _)) :: rest671))
 => let val  result = MlyValue.FUN_BIND' (fn _ => let val  (FUN_ID as 
FUN_ID1) = FUN_ID1 ()
 val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_ID as STR_ID1) = STR_ID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  SIG_EXP1 = SIG_EXP1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  COLON2 = COLON2 ()
 val  SIG_EXP2 = SIG_EXP2 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([FUN_ID, LPAREN, STR_ID, COLON, SIG_EXP1, RPAREN, COLON, SIG_EXP2, EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 79, ( result, FUN_ID1left, STR_EXP1right), rest671)

end
|  ( 290, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_EXP 
SIG_EXP2, _, _)) :: ( _, ( MlyValue.COLONGT COLONGT1, _, _)) :: ( _, (
 MlyValue.RPAREN RPAREN1, _, _)) :: ( _, ( MlyValue.SIG_EXP SIG_EXP1,
 _, _)) :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( 
MlyValue.STR_ID STR_ID1, _, _)) :: ( _, ( MlyValue.LPAREN LPAREN1, _,
 _)) :: ( _, ( MlyValue.FUN_ID FUN_ID1, FUN_ID1left, _)) :: rest671))
 => let val  result = MlyValue.FUN_BIND' (fn _ => let val  (FUN_ID as 
FUN_ID1) = FUN_ID1 ()
 val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (STR_ID as STR_ID1) = STR_ID1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  SIG_EXP1 = SIG_EXP1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (COLONGT as COLONGT1) = COLONGT1 ()
 val  SIG_EXP2 = SIG_EXP2 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([FUN_ID, LPAREN, STR_ID, COLON, SIG_EXP1, RPAREN, COLONGT, SIG_EXP2, EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 79, ( result, FUN_ID1left, STR_EXP1right), rest671)

end
|  ( 291, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.RPAREN 
RPAREN1, _, _)) :: ( _, ( MlyValue.SPEC SPEC1, _, _)) :: ( _, ( 
MlyValue.LPAREN LPAREN1, _, _)) :: ( _, ( MlyValue.FUN_ID FUN_ID1, 
FUN_ID1left, _)) :: rest671)) => let val  result = MlyValue.FUN_BIND'
 (fn _ => let val  (FUN_ID as FUN_ID1) = FUN_ID1 ()
 val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (SPEC as SPEC1) = SPEC1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (spacer'([FUN_ID, LPAREN, SPEC, RPAREN, EQUALOP, STR_EXP]))
end)
 in ( LrTable.NT 79, ( result, FUN_ID1left, STR_EXP1right), rest671)

end
|  ( 292, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_EXP 
SIG_EXP1, _, _)) :: ( _, ( MlyValue.COLON COLON1, _, _)) :: ( _, ( 
MlyValue.RPAREN RPAREN1, _, _)) :: ( _, ( MlyValue.SPEC SPEC1, _, _))
 :: ( _, ( MlyValue.LPAREN LPAREN1, _, _)) :: ( _, ( MlyValue.FUN_ID 
FUN_ID1, FUN_ID1left, _)) :: rest671)) => let val  result = 
MlyValue.FUN_BIND' (fn _ => let val  (FUN_ID as FUN_ID1) = FUN_ID1 ()
 val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (SPEC as SPEC1) = SPEC1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (COLON as COLON1) = COLON1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([FUN_ID, LPAREN, SPEC, RPAREN, COLON, SIG_EXP, EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 79, ( result, FUN_ID1left, STR_EXP1right), rest671)

end
|  ( 293, ( ( _, ( MlyValue.STR_EXP STR_EXP1, _, STR_EXP1right)) :: (
 _, ( MlyValue.EQUALOP EQUALOP1, _, _)) :: ( _, ( MlyValue.SIG_EXP 
SIG_EXP1, _, _)) :: ( _, ( MlyValue.COLONGT COLONGT1, _, _)) :: ( _, (
 MlyValue.RPAREN RPAREN1, _, _)) :: ( _, ( MlyValue.SPEC SPEC1, _, _))
 :: ( _, ( MlyValue.LPAREN LPAREN1, _, _)) :: ( _, ( MlyValue.FUN_ID 
FUN_ID1, FUN_ID1left, _)) :: rest671)) => let val  result = 
MlyValue.FUN_BIND' (fn _ => let val  (FUN_ID as FUN_ID1) = FUN_ID1 ()
 val  (LPAREN as LPAREN1) = LPAREN1 ()
 val  (SPEC as SPEC1) = SPEC1 ()
 val  (RPAREN as RPAREN1) = RPAREN1 ()
 val  (COLONGT as COLONGT1) = COLONGT1 ()
 val  (SIG_EXP as SIG_EXP1) = SIG_EXP1 ()
 val  (EQUALOP as EQUALOP1) = EQUALOP1 ()
 val  (STR_EXP as STR_EXP1) = STR_EXP1 ()
 in (
spacer'([FUN_ID, LPAREN, SPEC, RPAREN, COLONGT, SIG_EXP, EQUALOP, STR_EXP])
)
end)
 in ( LrTable.NT 79, ( result, FUN_ID1left, STR_EXP1right), rest671)

end
|  ( 294, ( ( _, ( MlyValue.FUN_BIND' FUN_BIND'1, FUN_BIND'1left, 
FUN_BIND'1right)) :: rest671)) => let val  result = MlyValue.FUN_BIND
 (fn _ => let val  (FUN_BIND' as FUN_BIND'1) = FUN_BIND'1 ()
 in (FUN_BIND')
end)
 in ( LrTable.NT 80, ( result, FUN_BIND'1left, FUN_BIND'1right), 
rest671)
end
|  ( 295, ( ( _, ( MlyValue.FUN_BIND FUN_BIND1, _, FUN_BIND1right)) ::
 ( _, ( MlyValue.AND AND1, _, _)) :: ( _, ( MlyValue.FUN_BIND' 
FUN_BIND'1, FUN_BIND'1left, _)) :: rest671)) => let val  result = 
MlyValue.FUN_BIND (fn _ => let val  (FUN_BIND' as FUN_BIND'1) = 
FUN_BIND'1 ()
 val  (AND as AND1) = AND1 ()
 val  (FUN_BIND as FUN_BIND1) = FUN_BIND1 ()
 in (FUN_BIND' ^ " " ^ AND ^ " " ^ FUN_BIND)
end)
 in ( LrTable.NT 80, ( result, FUN_BIND'1left, FUN_BIND1right), 
rest671)
end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.START x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : AssertEngine_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.EOF (fn () => i),p1,p2))
fun INT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.INT (fn () => i),p1,p2))
fun REAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.REAL (fn () => i),p1,p2))
fun WORD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.WORD (fn () => i),p1,p2))
fun CHAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.CHAR (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun EQUALOP (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.EQUALOP (fn () => i),p1,p2))
fun TIMES (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.TIMES (fn () => i),p1,p2))
fun SEMICOLON (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.SEMICOLON (fn () => i),p1,p2))
fun COMMA (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.COMMA (fn () => i),p1,p2))
fun DOT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.DOT (fn () => i),p1,p2))
fun ARROW (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.ARROW (fn () => i),p1,p2))
fun DARROW (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.DARROW (fn () => i),p1,p2))
fun BAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.BAR (fn () => i),p1,p2))
fun COLON (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.COLON (fn () => i),p1,p2))
fun COLONGT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.COLONGT (fn () => i),p1,p2))
fun HASH (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.HASH (fn () => i),p1,p2))
fun LCURLY (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.LCURLY (fn () => i),p1,p2))
fun RCURLY (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.RCURLY (fn () => i),p1,p2))
fun LBRACK (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.LBRACK (fn () => i),p1,p2))
fun RBRACK (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.RBRACK (fn () => i),p1,p2))
fun LPAREN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.LPAREN (fn () => i),p1,p2))
fun RPAREN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.RPAREN (fn () => i),p1,p2))
fun IF (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.IF (fn () => i),p1,p2))
fun THEN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.THEN (fn () => i),p1,p2))
fun ELSE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.ELSE (fn () => i),p1,p2))
fun WHILE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.WHILE (fn () => i),p1,p2))
fun DO (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.DO (fn () => i),p1,p2))
fun LET (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.LET (fn () => i),p1,p2))
fun IN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.IN (fn () => i),p1,p2))
fun END (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.END (fn () => i),p1,p2))
fun ORELSE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.ORELSE (fn () => i),p1,p2))
fun ANDALSO (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.ANDALSO (fn () => i),p1,p2))
fun HANDLE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.HANDLE (fn () => i),p1,p2))
fun RAISE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.RAISE (fn () => i),p1,p2))
fun EXCEPTION (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.EXCEPTION (fn () => i),p1,p2))
fun VAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VAL (fn () => i),p1,p2))
fun AND (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.AND (fn () => i),p1,p2))
fun FN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.FN (fn () => i),p1,p2))
fun FUN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.FUN (fn () => i),p1,p2))
fun CASE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.CASE (fn () => i),p1,p2))
fun OF (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.OF (fn () => i),p1,p2))
fun WILD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.WILD (fn () => i),p1,p2))
fun OP (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.OP (fn () => i),p1,p2))
fun REC (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.REC (fn () => i),p1,p2))
fun TYPE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.TYPE (fn () => i),p1,p2))
fun DATATYPE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.DATATYPE (fn () => i),p1,p2))
fun ABSTYPE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.ABSTYPE (fn () => i),p1,p2))
fun WITH (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.WITH (fn () => i),p1,p2))
fun WITHTYPE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.WITHTYPE (fn () => i),p1,p2))
fun AS (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.AS (fn () => i),p1,p2))
fun OPEN (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.OPEN (fn () => i),p1,p2))
fun LOCAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.LOCAL (fn () => i),p1,p2))
fun INFIX (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.INFIX (fn () => i),p1,p2))
fun INFIXR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.INFIXR (fn () => i),p1,p2))
fun NONFIX (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.NONFIX (fn () => i),p1,p2))
fun STRUCT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.STRUCT (fn () => i),p1,p2))
fun STRUCTURE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.STRUCTURE (fn () => i),p1,p2))
fun SIG (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.SIG (fn () => i),p1,p2))
fun SIGNATURE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.SIGNATURE (fn () => i),p1,p2))
fun FUNCTOR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.FUNCTOR (fn () => i),p1,p2))
fun INCLUDE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.INCLUDE (fn () => i),p1,p2))
fun WHERE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.WHERE (fn () => i),p1,p2))
fun EQTYPE (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.EQTYPE (fn () => i),p1,p2))
fun SHARING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.SHARING (fn () => i),p1,p2))
fun DOTTED_WILDCARD (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.DOTTED_WILDCARD (fn () => i),p1,p2))
fun LASSERT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.LASSERT (fn () => i),p1,p2))
fun RASSERT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.RASSERT (fn () => i),p1,p2))
fun REQUIRES (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.REQUIRES (fn () => i),p1,p2))
fun ENSURES (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.ENSURES (fn () => i),p1,p2))
fun SYMBOLS (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.SYMBOLS (fn () => i),p1,p2))
fun QUOTE_ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.QUOTE_ID (fn () => i),p1,p2))
fun ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.ID (fn () => i),p1,p2))
end
end
